{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{620:function(n,t,e){\"use strict\";e.r(t);var a=e(4),v=Object(a.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":n.$parent.slotKey}},[e(\"p\",[e(\"img\",{attrs:{src:\"https://pic.leetcode-cn.com/86c8ce53d2a91f3d710fdba825333be582a15bd661e9f05a10278bf558fbf1ef-1.png\",alt:\"1.png\"}})]),n._v(\" \"),e(\"p\",[n._v(\"文章目录：\")]),n._v(\" \"),e(\"ol\",[e(\"li\",[n._v(\"什么是递归\")]),n._v(\" \"),e(\"li\")]),n._v(\" \"),e(\"p\",[e(\"strong\",[n._v(\"什么是递归\")])]),n._v(\" \"),e(\"p\",[n._v(\"递归的基本思想是某个函数直接或者间接地调用自身，这样就把原问题的求解转换为许多性质相同但是规模更小的子问题。我们只需要关注如何把原问题划分成符合条件的子问题，而不需要去研究这个子问题是如何被解决的。递归和枚举的区别在于：枚举是横向地把问题划分，然后依次求解子问题，而递归是把问题逐级分解，是纵向的拆分。\")]),n._v(\" \"),e(\"p\",[e(\"strong\",[n._v(\"简单地说，就是如果在函数中存在着调用函数本身的情况，这种现象就叫递归。\")])]),n._v(\" \"),e(\"p\",[n._v(\"你以前肯定写过递归，只是不知道这就是递归罢了。\")]),n._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://www.noction.com/wp-content/uploads/2018/10/Recursion-example-technology-nested-virtualization.png\",alt:\"Recursion example technology nested virtualization\"}})]),n._v(\" \"),e(\"p\",[n._v(\"以阶乘函数为例,如下, 在 factorial 函数中存在着 factorial(n - 1) 的调用，所以此函数是递归函数\")]),n._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[n._v(\"public int factorial(int n) {\\n    if (n < =1) {\\n        return1;\\n    }\\n    return n * factorial(n - 1)\\n}\\nint fibonacci(int n) {\\n   // Base case\\n   if (n == 0 || n == 1) return n;\\n\\n   // Recursive step\\n   return fibonacci(n-1) + fibonacci(n-2);\\n}\\n\")])])]),e(\"p\",[n._v(\"进一步剖析「递归」，先有「递」再有「归」，「递」的意思是将问题拆解成子问题来解决， 子问题再拆解成子子问题，...，直到被拆解的子问题无需再拆分成更细的子问题（即可以求解），「归」是说最小的子问题解决了，那么它的上一层子问题也就解决了，上一层的子问题解决了，上上层子问题自然也就解决了,....,直到最开始的问题解决,文字说可能有点抽象，那我们就以阶层 f(6) 为例来看下它的「递」和「归」。\")]),n._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLWvDS0Xny7l5kj0Nj4znUDibKqgKHPzVqr7eXnSbuR7icf21OrBa8Fzcc0gF2XP9licCFkG6iaibrC5cgA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\",alt:\"img\"}})]),n._v(\" \"),e(\"p\",[n._v(\"求解问题 f(6), 由于 f(6) = n * f(5), 所以 f(6) 需要拆解成 f(5) 子问题进行求解，同理 f(5) = n * f(4) ,也需要进一步拆分,... ,直到 f(1), 这是「递」，f(1) 解决了，由于 f(2) =  2 f(1) = 2 也解决了,.... f(n)到最后也解决了，这是「归」，所以递归的本质是能把问题拆分成具有\"),e(\"strong\",[n._v(\"相同解决思路\")]),n._v(\"的子问题，。。。直到最后被拆解的子问题再也不能拆分，解决了最小粒度可求解的子问题后，在「归」的过程中自然顺其自然地解决了最开始的问题。\")]),n._v(\" \"),e(\"p\",[n._v(\"递归原理\")]),n._v(\" \"),e(\"hr\"),n._v(\" \"),e(\"blockquote\",[e(\"p\",[n._v(\"递归是一种解决问题的有效方法，在递归过程中，函数将自身作为子例程调用\")])]),n._v(\" \"),e(\"p\",[n._v(\"你可能想知道如何实现调用自身的函数。诀窍在于，每当递归函数调用自身时，它都会将给定的问题拆解为子问题。递归调用继续进行，直到到子问题无需进一步递归就可以解决的地步。\")]),n._v(\" \"),e(\"p\",[n._v(\"为了确保递归函数不会导致无限循环，它应具有以下属性：\")]),n._v(\" \"),e(\"ol\",[e(\"li\",[n._v(\"一个简单的\"),e(\"code\",[n._v(\"基本案例（basic case）\")]),n._v(\"（或一些案例） —— 能够不使用递归来产生答案的终止方案。\")]),n._v(\" \"),e(\"li\",[n._v(\"一组规则，也称作\"),e(\"code\",[n._v(\"递推关系（recurrence relation）\")]),n._v(\"，可将所有其他情况拆分到基本案例。\")])]),n._v(\" \"),e(\"p\",[n._v(\"注意，函数可能会有多个位置进行自我调用。\")]),n._v(\" \"),e(\"p\",[n._v(\"递归的基本思想是某个函数直接或者间接地调用自身，这样就把原问题的求解转换为许多性质相同但是规模更小的子问题。我们只需要关注如何把原问题划分成符合条件的子问题，而不需要去研究这个子问题是如何被解决的。递归和枚举的区别在于：枚举是横向地把问题划分，然后依次求解子问题，而递归是把问题逐级分解，是纵向的拆分。\")]),n._v(\" \"),e(\"p\",[n._v(\"递归代码最重要的两个特征：结束条件和自我调用。自我调用是在解决子问题，而结束条件定义了最简子问题的答案。\")]),n._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[n._v(\"int func(你今年几岁) {\\n    // 最简子问题，结束条件\\n    if (你1999年几岁) return 我0岁;\\n    // 自我调用，缩小规模\\n    return func(你去年几岁) + 1;   \\n}\\n\")])])]),e(\"h3\",{attrs:{id:\"反转字符串-344\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#反转字符串-344\"}},[n._v(\"#\")]),n._v(\" 反转字符串(344)\")]),n._v(\" \"),e(\"blockquote\",[e(\"p\",[n._v(\"编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 \"),e(\"code\",[n._v(\"char[]\")]),n._v(\" 的形式给出。\")]),n._v(\" \"),e(\"p\",[n._v(\"不要给另外的数组分配额外的空间，你必须\"),e(\"strong\",[n._v(\"原地修改输入数组\")]),n._v(\"、使用 O(1) 的额外空间解决这一问题。\")]),n._v(\" \"),e(\"p\",[n._v(\"你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。\")]),n._v(\" \"),e(\"p\",[e(\"strong\",[n._v(\"示例 1：\")])]),n._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[n._v('输入：[\"h\",\"e\",\"l\",\"l\",\"o\"]\\n输出：[\"o\",\"l\",\"l\",\"e\",\"h\"]\\n')])])])])])}),[],!1,null,null,null);t.default=v.exports}}]);","extractedComments":[]}