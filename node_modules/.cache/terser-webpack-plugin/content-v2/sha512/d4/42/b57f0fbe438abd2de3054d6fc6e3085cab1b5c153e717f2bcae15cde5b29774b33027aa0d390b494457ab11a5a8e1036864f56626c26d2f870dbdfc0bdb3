{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[134],{689:function(v,_,i){\"use strict\";i.r(_);var l=i(4),t=Object(l.a)({},(function(){var v=this,_=v.$createElement,i=v._self._c||_;return i(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":v.$parent.slotKey}},[i(\"h3\",{attrs:{id:\"类加载子系统\"}},[i(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#类加载子系统\"}},[v._v(\"#\")]),v._v(\" 类加载子系统\")]),v._v(\" \"),i(\"ul\",[i(\"li\",[v._v(\"类加载机制？类加载过程\")]),v._v(\" \"),i(\"li\",[v._v(\"什么是类加载器，类加载器有哪些？这些类加载器都加载哪些文件？\")]),v._v(\" \"),i(\"li\",[v._v(\"多线程的情况下，类的加载为什么不会出现重复加载的情况？\")]),v._v(\" \"),i(\"li\",[v._v(\"什么是双亲委派机制？它有啥优势？可以打破这种机制吗？\")]),v._v(\" \"),i(\"li\",[v._v(\"自定义了一个String，那么会加载哪个String？\")])]),v._v(\" \"),i(\"h3\",{attrs:{id:\"内存管理\"}},[i(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#内存管理\"}},[v._v(\"#\")]),v._v(\" 内存管理\")]),v._v(\" \"),i(\"ul\",[i(\"li\",[v._v(\"Java内存分配\")]),v._v(\" \"),i(\"li\",[v._v(\"内存泄露和内存溢出\")]),v._v(\" \"),i(\"li\",[v._v(\"永久代、元空间、方法区的关系\")]),v._v(\" \"),i(\"li\",[v._v(\"如何覆盖 JDK 提供的组件，比如覆盖 ArrayList 的实现\")]),v._v(\" \"),i(\"li\",[v._v(\"new 一个对象的过程发生了什么（类加载、变量初始化、内存分配）\")]),v._v(\" \"),i(\"li\",[v._v(\"对象的死亡过程\")]),v._v(\" \"),i(\"li\",[v._v(\"JVM 可能会抛出哪些 OOM\")]),v._v(\" \"),i(\"li\",[v._v(\"String内容存放在哪儿\")]),v._v(\" \"),i(\"li\",[v._v(\"举例栈溢出的情况？\")])]),v._v(\" \"),i(\"h3\",{attrs:{id:\"gc\"}},[i(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#gc\"}},[v._v(\"#\")]),v._v(\" GC\")]),v._v(\" \"),i(\"ul\",[i(\"li\",[v._v(\"为什么要有GC\")]),v._v(\" \"),i(\"li\",[v._v(\"简述垃圾回收机制\")]),v._v(\" \"),i(\"li\",[v._v(\"深拷贝和浅拷贝\")]),v._v(\" \"),i(\"li\",[v._v(\"System.gc() 和 Runtime.gc() 会做什么事情\")]),v._v(\" \"),i(\"li\",[v._v(\"垃圾回收算法有哪些？优缺点比较\")]),v._v(\" \"),i(\"li\",[v._v(\"熟知的垃圾回收器有哪些，简单描述每个应用场景\")]),v._v(\" \"),i(\"li\",[v._v(\"CMS 和 G1 的垃圾回收步骤是？\")]),v._v(\" \"),i(\"li\",[v._v(\"G1 相对于 CMS 的优缺点\")]),v._v(\" \"),i(\"li\",[v._v(\"可达性分析算法中根节点有哪些\")])]),v._v(\" \"),i(\"h3\",{attrs:{id:\"性能监控与调优\"}},[i(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#性能监控与调优\"}},[v._v(\"#\")]),v._v(\" 性能监控与调优\")]),v._v(\" \"),i(\"ul\",[i(\"li\",[v._v(\"如何监控 GC\")]),v._v(\" \"),i(\"li\",[v._v(\"常见 OutOfMemoryError 有哪些\")]),v._v(\" \"),i(\"li\",[v._v(\"常见的 JDK 诊断命令有哪些，应用场景？\")]),v._v(\" \"),i(\"li\",[v._v(\"CPU 较高，如何定位问题\")]),v._v(\" \"),i(\"li\",[v._v(\"内存占用较高，如何定位大对象\")]),v._v(\" \"),i(\"li\",[v._v(\"内存泄漏时，如何实时跟踪内存变化情况\")]),v._v(\" \"),i(\"li\",[v._v(\"内存泄漏时，如何定位问题代码\")]),v._v(\" \"),i(\"li\",[v._v(\"大型项目如何进行性能瓶颈调优？\")])]),v._v(\" \"),i(\"h3\",{attrs:{id:\"虚拟机子系统\"}},[i(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#虚拟机子系统\"}},[v._v(\"#\")]),v._v(\" 虚拟机子系统\")]),v._v(\" \"),i(\"ul\",[i(\"li\",[v._v(\"字节码是如何在 JVM 中进行流转的（栈帧）\")]),v._v(\" \"),i(\"li\",[v._v(\"方法调用的底层实现\")]),v._v(\" \"),i(\"li\",[v._v(\"方法重写和重载的实现过程\")]),v._v(\" \"),i(\"li\",[v._v(\"invokedynamic 指令实现\")]),v._v(\" \"),i(\"li\",[v._v(\"如何修改字节码\")]),v._v(\" \"),i(\"li\",[v._v(\"JIT 参数配置如何影响程序运行？\")]),v._v(\" \"),i(\"li\",[v._v(\"虚拟机有哪些性能优化策略\")])]),v._v(\" \"),i(\"h3\",{attrs:{id:\"jmm内存模型-应该归到juc下\"}},[i(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jmm内存模型-应该归到juc下\"}},[v._v(\"#\")]),v._v(\" JMM内存模型(应该归到JUC下)\")]),v._v(\" \"),i(\"ul\",[i(\"li\",[v._v(\"为什么要有内存模型\")]),v._v(\" \"),i(\"li\",[v._v(\"简单描述 JMM 和 JVM 两个概念\")]),v._v(\" \"),i(\"li\",[v._v(\"你知道 Java 内存模型 JMM 吗？那你知道它的三大特性吗？\")]),v._v(\" \"),i(\"li\",[v._v(\"Java 是如何解决指令重排问题的？\")]),v._v(\" \"),i(\"li\",[v._v(\"为什么要重排序，重排序在什么时候排\")]),v._v(\" \"),i(\"li\",[v._v(\"如何约束重排序规则\")]),v._v(\" \"),i(\"li\",[v._v(\"happens-before\")]),v._v(\" \"),i(\"li\",[v._v(\"什么是顺序一致性\")]),v._v(\" \"),i(\"li\",[v._v(\"原子性，可见性，有序性如何保证\")]),v._v(\" \"),i(\"li\",[v._v(\"volatile\")]),v._v(\" \"),i(\"li\",[v._v(\"volatile 内存语义，什么时候用，用的时候需要考虑什么问题\")]),v._v(\" \"),i(\"li\",[v._v(\"既然CPU有缓存一致性协议（MESI），为什么 JMM 还需要 volatile 关键字？\")]),v._v(\" \"),i(\"li\",[v._v(\"CAS 实现的原理，是阻塞还是非阻塞方式？什么时候用，使用时需要考虑的问题\")]),v._v(\" \"),i(\"li\",[v._v(\"处理器和 Java 分别怎么保证原子操作\")]),v._v(\" \"),i(\"li\",[v._v(\"保证了原子性就能保证可见性吗？\")]),v._v(\" \"),i(\"li\",[v._v(\"final 内存语义？什么时候用，使用时需要考虑的问题\")]),v._v(\" \"),i(\"li\",[v._v(\"synchronized 内存语义，什么时候用，和锁比较一下优缺点\")]),v._v(\" \"),i(\"li\",[v._v(\"synchronized 中涉及的锁升级流程\")]),v._v(\" \"),i(\"li\",[v._v(\"锁的内存语义，举例说明，加锁失败时候的处理流程\")]),v._v(\" \"),i(\"li\",[v._v(\"比较下 CAS 、volatile 、synchronized、Lock 区别\")]),v._v(\" \"),i(\"li\",[v._v(\"原子操作类底层实现机制？自增操作是怎么保证原子性的？\")])])])}),[],!1,null,null,null);_.default=t.exports}}]);","extractedComments":[]}