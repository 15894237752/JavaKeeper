`数组`是数据结构中的基本模块之一。因为`字符串`是由字符数组形成的，所以二者是相似的。大多数面试问题都属于这个范畴。



`数组`是一种基本的数据结构，用于按顺序`存储元素的集合`。但是元素可以随机存取，因为数组中的每个元素都可以通过数组`索引`来识别。

数组可以有一个或多个维度。这里我们从`一维数组`开始，它也被称为线性数组。这里有一个例子：

![img](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/31/screen-shot-2018-03-20-at-191856.png)

在上面的例子中，数组 A 中有 6 个元素。也就是说，A 的长度是 6 。我们可以使用 A[0] 来表示数组中的第一个元素。因此，A[0] = 6 。类似地，A[1] = 3，A[2] = 8，依此类推。



### 动态数组

数组具有`固定的容量`，我们需要在初始化时指定数组的大小。有时它会非常不方便并可能造成浪费。

因此，大多数编程语言都提供内置的`动态数组`，它仍然是一个随机存取的列表数据结构，但`大小是可变的`。例如，在 C++ 中的 `vector`，以及在 Java 中的 `ArrayList`。

https://leetcode-cn.com/explore/learn/card/array-and-string/198/introduction-to-array/772/

#### 寻找数组的中心索引

给定一个整数类型的数组 `nums`，请编写一个能够返回数组**“中心索引”**的方法。

我们是这样定义数组**中心索引**的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。

如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。



#### 至少是其他数字两倍的最大数

在一个给定的数组`nums`中，总是存在一个最大元素 。

查找数组中的最大元素是否至少是数组中每个其他数字的两倍。

如果是，则返回最大元素的索引，否则返回-1。

#### 加一

给定一个由**整数**组成的**非空**数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储**单个**数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。



## 二维数组

类似于一维数组，`二维数组`也是由元素的序列组成。但是这些元素可以排列在矩形网格中而不是直线上。

在一些语言中，多维数组实际上是在`内部`作为一维数组实现的，而在其他一些语言中，`实际上`根本没有`多维数组`。

**1. C++ 将二维数组存储为一维数组。**

下图显示了*大小为 M \* N 的数组 A* 的实际结构：

![img](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/31/screen-shot-2018-03-31-at-161748.png)

因此，如果我们将 A 定义为也包含 *M \* N* 个元素的一维数组，那么实际上 A[i][j] 就等于 A[i * N + j]。

 

**2. 在Java中，二维数组实际上是包含着 M 个元素的一维数组，每个元素都是包含有 N 个整数的数组。**

下图显示了 Java 中二维数组 A 的实际结构：

![img](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/31/screen-shot-2018-03-31-at-162857.png)

#### 对角线遍历

给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素

#### 螺旋矩阵

给定一个包含 *m* x *n* 个元素的矩阵（*m* 行, *n* 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。

#### 杨辉三角

给定一个非负整数 *numRows，*生成杨辉三角的前 *numRows* 行。



# 字符串

字符串实际上是一个 `unicode 字符`数组。你可以执行几乎所有我们在数组中使用的操作。然而，二者之间还是存在一些区别。



### 比较函数

------

字符串有它自己的`比较函数`（我们将在下面的代码中向你展示比较函数的用法）。

然而，存在这样一个问题：

> 我们可以用 “==” 来比较两个字符串吗？

这取决于下面这个问题的答案：

> 我们使用的语言是否支持`运算符重载`？

1. 如果答案是 `yes` （例如 C++）。我们`可以使用` “==” 来比较两个字符串。
2. 如果答案是 `no` （例如 Java），我们`可能无法使用` “==” 来比较两个字符串。当我们使用 “==” 时，它实际上会比较这两个对象是否是同一个对象。

### 是否可变

------

不可变意味着一旦字符串被初始化，你就无法改变它的内容。

1. 在某些语言（如 C ++）中，字符串是`可变的`。 也就是说，你可以像在数组中那样修改字符串。
2. 在其他一些语言（如 Java）中，字符串是不可变的。 此特性将带来一些问题。 我们将在下一篇文章中阐明问题和解决方案。

### 额外操作

------

与数组相比，我们可以对字符串执行一些额外的操作



#### 二进制求和

给定两个二进制字符串，返回他们的和（用二进制表示）。

输入为**非空**字符串且只包含数字 `1` 和 `0`。

#### 实现 strStr()

实现 [strStr()](https://baike.baidu.com/item/strstr/811469) 函数。

给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 **-1**。

#### 最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。



### 双指针技巧 

通常，我们只使用从第一个元素开始并在最后一个元素结束的一个指针来进行迭代。 但是，有时候，我们可能需要`同时使用两个指针`来进行迭代

一个经典问题：

> 反转数组中的元素。

其思想是将第一个元素与末尾进行交换，再向前移动到下一个元素，并不断地交换，直到它到达中间位置。

我们可以同时使用两个指针来完成迭代：一个`从第一个元素开始`，另一个`从最后一个元素开始`。持续交换它们所指向的元素，直到这两个指针相遇。



使用双指针技巧的典型场景之一是你想要

> 从两端向中间迭代数组。

这时你可以使用双指针技巧：

> 一个指针从始端开始，而另一个指针从末端开始。

值得注意的是，这种技巧经常在`排序`数组中使用。



#### 反转字符串

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `char[]` 的形式给出。

不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 [ASCII](https://baike.baidu.com/item/ASCII) 码表中的可打印字符。

 

#### 数组拆分 I

给定长度为 **2n** 的数组, 你的任务是将这些数分成 **n** 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。



####  两数之和 II - 输入有序数组

给定一个已按照***升序排列\*** 的有序数组，找到两个数使得它们相加之和等于目标数。

函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2*。*

**说明:**

- 返回的下标值（index1 和 index2）不是从零开始的。
- 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。



有时，我们可以使用`两个不同步的指针`来解决问题。

让我们从另一个经典问题开始：

> 给定一个数组和一个值，[原地](https://en.wikipedia.org/wiki/In-place_algorithm)删除该值的所有实例并返回新的长度。

如果我们没有空间复杂度上的限制，那就更容易了。我们可以初始化一个新的数组来存储答案。如果元素不等于给定的目标值，则迭代原始数组并将元素添加到新的数组中。

实际上，它相当于使用了两个指针，一个用于原始数组的迭代，另一个总是指向新数组的最后一个位置。

###  重新考虑空间限制

现在让我们重新考虑空间受到限制的情况。 

我们可以采用类似的策略，我们继续使用两个指针：一个仍然用于迭代，而第二个指针总是指向`下一次添加的位置`。

```
public int removeElement(int[] nums, int val) {
    int k = 0;
    for (int i = 0; i < nums.length; ++i) {
        if (nums[i] != val) {
            nums[k] = nums[i];
            k++;
        }
    }
    return k;
}
```

在上面的例子中，我们使用两个指针，一个快指针 `i` 和一个慢指针 `k` 。`i` 每次移动一步，而 `k` 只在添加新的被需要的值时才移动一步。

------

这是你需要使用双指针技巧的一种非常常见的情况：

> 同时有一个慢指针和一个快指针。

解决这类问题的关键是

> 确定两个指针的移动策略。

与前一个场景类似，你有时可能需要在使用双指针技巧之前对数组进行排序，也可能需要运用贪心想法来决定你的运动策略。



#### 移除元素

给你一个数组 *nums* 和一个值 *val*，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 *val* 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组**。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。



#### 最大连续1的个数

给定一个二进制数组， 计算其中最大连续1的个数。



#### 长度最小的子数组

给定一个含有 **n** 个正整数的数组和一个正整数 **s ，**找出该数组中满足其和 **≥ s** 的长度最小的连续子数组**。**如果不存在符合条件的连续子数组，返回 0。



