从 JMM 到 volatile

> 谈谈你对volatile 的理解？
>
> CAS 你知道吗？ 



 ![img](https://miro.medium.com/max/643/0*aO7jvEaMLhADKTqa) 

## 硬件内存架构(Hardware Memory Architecture)

计算机硬件架构简易图：

 ![Modern hardware memory architecture.](http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-4.png) 

前两天看到同学和我显摆他们公司配的电脑多好多好，我默默打开了自己的电脑，` 酷睿 i7-4770 `，也不是不够用哈，4核8线程的 CPU，也是杠杠的。

扯着玩意干啥，嗯嗯~~~~

每个CPU包含一组寄存器，这些寄存器本质上是在CPU内存中。CPU在这些寄存器上执行操作的速度要比在主内存中执行变量的速度快得多。这是因为CPU访问这些寄存器的速度要比访问主存的速度快得多。

每个CPU也可以有一个CPU缓存内存层。实际上，大多数现代cpu都有某种大小的缓存内存层。CPU可以比主存更快地访问它的高速缓存内存，但通常没有访问内部寄存器的速度快。因此，CPU高速缓冲存储器的速度介于内部寄存器和主存之间。一些cpu可能有多个缓存层(级别1和级别2)，但是了解Java内存模型如何与内存交互并不重要。重要的是要知道cpu可以有某种类型的缓存内存层。 

计算机还包含一个主内存区域(RAM)。所有的cpu都可以访问主存。主内存区域通常比cpu的缓存内存大得多。 

通常，当CPU需要访问主内存时，它会将一部分主内存读入CPU缓存。它甚至可以将缓存的一部分读入内部寄存器，然后对其执行操作。当CPU需要将结果写回主内存时，它会将值从内部寄存器刷新到缓存内存，并在某个时候将值刷新回主内存。 

当CPU需要在高速缓存内存中存储其他内容时，通常会将存储在高速缓存内存中的值刷新回主内存。CPU缓存可以一次将数据写入一部分内存，并一次刷新一部分内存。它不必每次更新时都读取/写入完整的缓存。通常，缓存是在称为“缓存线”的较小内存块中更新的。一条或多条高速缓存线路可能被读入高速缓存内存，而一条或多条高速缓存线路可能被再次刷新回主存。 



Java内存模型和硬件内存体系结构是不同的。硬件内存体系结构不区分线程栈和堆。在硬件上，线程栈和堆都位于主内存中。线程栈和堆的一部分有时可能出现在CPU缓存和内部CPU寄存器中。如下图所示: 

![The division of thread stack and heap among CPU internal registers, CPU cache and main memory.](http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-5.png) 

当对象和变量可以存储在计算机中不同的内存区域时，可能会出现某些问题。两个主要问题是:

- 线程更新(写)到共享变量的可见性。

- 读取、检查和写入共享变量时的竞争条件。

### Visibility of Shared Objects

如果两个或多个线程共享一个对象，而没有适当地使用volatile声明或同步，则一个线程对共享对象的更新可能对其他线程不可见。
假设共享对象最初存储在主内存中。在CPU 1上运行的线程然后将共享对象读入它的CPU缓存。在这里，它对共享对象进行更改。只要没有将CPU缓存刷新回主内存，在其他CPU上运行的线程就不会看到共享对象的更改版本。这样，每个线程都可能以自己的线程结束

 ![Visibility Issues in the Java Memory Model.](http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-6.png) 



要解决这个问题，可以使用Java的volatile关键字。volatile关键字可以确保直接从主存读取给定的变量，并在更新时始终将其写回主存。 

### Race Conditions

如果两个或多个线程共享一个对象，并且多个线程更新该共享对象中的变量，则可能出现竞争条件。
想象一下，如果线程A将一个共享对象的变量计数读入到它的CPU缓存中。此时，线程B执行相同的操作，但是进入不同的CPU缓存。现在线程A将1添加到count中，线程B也这样做。现在var1增加了两次，在每个CPU缓存中一次。

如果这些增量是按顺序执行的，则变量计数将增加两次，并将原始值+ 2写回主内存。
然而,

 ![Race Condition Issues in the Java Memory Model.](http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-7.png) 

要解决这个问题，可以使用Java synchronized块。同步块保证在任何给定时间只有一个线程可以进入给定的代码临界段。Synchronized块还保证在Synchronized块中访问的所有变量都将从主内存中读入，当线程退出Synchronized块时，所有更新的变量都将被再次刷新回主内存，而不管变量是否声明为volatile。 







我们都知道处理器与计算机存储设备运算速度有几个数量级的差别。总不能让处理器总是等待计算机存储设备，这样就没办法显现出处理器的优势。

因此，为了“压榨”处理的性能，达到“高并发”的效果，在处理器和存储设备之间加入了高速缓存（cache）来作为缓冲。


![JMM](http://www.choupangxia.com/wp-content/uploads/2019/11/computer.jpg) 

将运算需要使用到的数据复制到缓存中，让运算能够快速进行。当运算完成之后，再将缓存中的结果写入主内存，这样运算器就不用等待主内存的读写操作了。

每个处理器都有自己的高速缓存，同时又共同操作同一块主内存，当多个处理器同时操作主内存时，可能导致数据不一致，因此需要“缓存一致性协议”来保障。比如，MSI、MESI等




## Java内存模型（Java Memory Model）

Java内存模型即`Java Memory Model`，简称 JMM。。

 Java内存模型指定Java虚拟机如何与计算机内存(RAM)一起工作。Java虚拟机是整个计算机的模型，因此这个模型自然包括内存模型—即Java内存模型。 用来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各平台下都能够达到一致的内存访问效果

JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。


 ![JMM](http://www.choupangxia.com/wp-content/uploads/2019/11/jmm-1.jpg) 

JMM与Java内存结构并不是同一个层次的内存划分，两者基本没有关系。如果一定要勉强对应，那从变量、主内存、工作内存的定义看，主内存主要对应Java堆中的对象实例数据部分，工作内存则对应虚拟机栈的部分区域。

![JMM](http://www.choupangxia.com/wp-content/uploads/2019/11/jmm-2.jpg)

主内存：主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)，当然也包括了共享的类信息、常量、静态变量。共享数据区域，多条线程对同一个变量进行访问可能会发现线程安全问题。

工作内存：主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关Native方法的信息。由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。

JMM模型与硬件模型直接的对照关系可简化为下图：![JMM](https://user-gold-cdn.xitu.io/2019/11/4/16e348b63f897229?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 内存之间的交互操作

线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。

![JMM](https://user-gold-cdn.xitu.io/2019/11/4/16e348b79e8bcbd4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

如上图，本地内存A和B有主内存中共享变量x的副本，初始值都为0。线程A执行之后把x更新为1，存放在本地内存A中。当线程A和线程B需要通信时，线程A首先会把本地内存中x=1值刷新到主内存中，主内存中的x值变为1。随后，线程B到主内存中去读取更新后的x值，线程B的本地内存的x值也变为了1。

在此交互过程中，Java内存模型定义了8种操作来完成，虚拟机实现必须保证每一种操作都是原子的、不可再拆分的（double和long类型例外）。

- lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。 
- unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 
- read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。 
- load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 
- use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。 
- assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 
- store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。 
- write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。 

如果需要把一个变量从主内存复制到工作内存，那就要顺序地执行read和load操作，如果要把变量从工作内存同步回主内存，就要顺序地执行store和write操作。注意，Java内存模型只要求上述两个操作必须按顺序执行，而没有保证是连续执行。也就是说read与load之间、store与write之间是可插入其他指令的，如对主内存中的变量a、b进行访问时，一种可能出现顺序是read a、read b、load b、load a。除此之外，Java内存模型还规定了在执行上述8中基本操作时必须满足如下规则。

- 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。 
- 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。 
- 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存。 
- 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作。 
- 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。 
- 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。 
- 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。 
- 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。 

## long和double型变量的特殊规则

Java内存模型要求lock，unlock，read，load，assign，use，store，write这8个操作都具有原子性，但对于64位的数据类型（long或double），在模型中定义了一条相对宽松的规定，允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load，store，read，write这4个操作的原子性，即long和double的非原子性协定。

如果多线程的情况下double或long类型并未声明为volatile，可能会出现“半个变量”的数值，也就是既非原值，也非修改后的值。

虽然Java规范允许上面的实现，但商用虚拟机中基本都采用了原子性的操作，因此在日常使用中几乎不会出现读取到“半个变量”的情况。









学习 volatile 之前先来来接下 JMM



JMM ()



我们常说的JVM内存模式指的是JVM的内存分区；而Java内存模式是一种虚拟机规范。

Java虚拟机规范中定义了Java内存模型（Java Memory Model，JMM），用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。



原始的Java内存模型存在一些不足，因此Java内存模型在Java1.5时被重新修订。这个版本的Java内存模型在Java8中仍然在使用。

Java内存模型（不仅仅是JVM内存分区）：调用栈和本地变量存放在线程栈上，对象存放在堆上。

![img](https://pic2.zhimg.com/80/v2-bd607bd9a5598a8330ad329033e04b91_720w.jpg)

![img](https://pic3.zhimg.com/80/v2-a1a75c9f7264cf78d0927663371ca9d2_720w.jpg)



## JMM

JMM（Java内存模型 Java Memory Model，简称JMM）,不同于我们了解的 Java 内存区域，JMM 本身是一种抽象的概念**并不真实存在**，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。

JMM关于同步的规定

- 线程解锁前，必须把共享变量的值刷新回主内存
- 线程加锁前，必须读取主内存的最新值到自己的工作内存
- 加锁解锁是同一把锁

由于 JVM 运行程序的实体是线程，而每个线程创建时 JVM 都会为其创建一个工作内存（栈空间），工作内存是每个线程的私有数据区域，而 Java 内存模型中规定所有变量都存储在主内存中，主内存是共享内存区域，所有线程都可以访问，**但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量**，各个线程中的工作内存中存储着主内存中的**变量副本拷贝**，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，其简要访问过程如下：



![](https://tva1.sinaimg.cn/large/00831rSTly1gcrgct554oj30qe0d441o.jpg)



JMM 要保证三个特性

- 可见性

  各个线程对主内存中共享变量的操作都是各个线程各自拷贝到自己的工作内存进行操作后再写回到主内存中的。这就可能存在一个线程 Thread1 修改了共享变量X的值但未写回主内存中，另外一个线程 Thread2 又对主内存中同一共享变量 X 进行操作，但此时 Thread1 线程工作内存中共享变量 X 对线程 Thread2 来说并不可见，这种工作内存与主内存同步延迟现象就造成了可见性问题

- 原子性

- 有序性

  计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排，一般分为以下 3 种

  ![](https://tva1.sinaimg.cn/large/00831rSTly1gcrgrycnj0j31bs04k74y.jpg)

  单线程环境里确保程序最终执行结果和代码顺序执行的结果一致

  处理器在进行重排序时必须要考虑指令之间的**数据依赖性**

  多项成环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测

![](/Users/starfish/Desktop/截屏2020-03-12上午11.47.50.png)

![](https://tva1.sinaimg.cn/large/00831rSTly1gcrgi74ulmj31im0qin9a.jpg)

变量的赋能拷贝







![](https://tva1.sinaimg.cn/large/00831rSTly1gcrgu63mbnj30su0i4whz.jpg)



数据依赖性，所以4不会是第一条

![](https://tva1.sinaimg.cn/large/00831rSTly1gcrgufti8zj31f40mg0xf.jpg)

![](https://tva1.sinaimg.cn/large/00831rSTly1gcrguq8arkj31f80nidyx.jpg)

![](https://tva1.sinaimg.cn/large/00831rSTly1gcrgvj393uj31fa0m8n73.jpg)



线程安全性获得保证

工作内存与主内存同步延迟现象导致的可见性问题，可以使用synchronized或 volatile 关键字解决，他们可以使一个线程修改后的变量立即对其他线程可见。





![](https://tva1.sinaimg.cn/large/00831rSTly1gcrgwjpoekj31dg0nynfc.jpg)





### 1.   volatile 关键字 内存可见性	

**可见性：**

　　可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。

　　**可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。**也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如  volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++  依然是一个非原子操作，也就是这个操作同样存在线程安全问题。

　　在 Java 中 volatile、synchronized 和 final 实现可见性。

**原子性：**

　　**原子是世界上的最小单位，具有不可分割性。**比如  a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a = a +   1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。

　　在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性。

**有序性：**

　　Java  语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile  是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock  操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。



- Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。

　　**在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。** 

- 当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。

- 而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。



volatile 是 Java 虚拟机提供的轻量级的同步机制

- 保证可见性
- 不保证原子性
- 禁止指令重排





#### 当一个变量定义为 volatile 之后，将具备两种特性：

1. 保证此变量对所有的线程的可见性，这里的“可见性”，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：[Java内存模型](http://www.cnblogs.com/zhengbin/p/6407137.html)）来完成。
2. 禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个**内存屏障**（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。

#### volatile 性能：

　　volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。

### 2.   原子变量 CAS算法 

#### CAS 算法

- CAS (Compare-And-Swap) 是一种硬件对并发的支持，针对多处理器 操作而设计的处理器中的一种特殊指令，用于管理对共享数据的并发访问。 
- CAS 是一种无锁的非阻塞算法的实现。 
- CAS 包含了 3 个操作数：
  - 需要读写的内存值 V 
  - 进行比较的值 A 
  - 拟写入的新值 B 
- 当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的 值，否则不会执行任何操作。 



#### 原子变量 

- 类的小工具包，支持在单个变量上解除锁的线程安全编程。事实上，此包中的类可 将 volatile 值、字段和数组元素的概念扩展到那些也提供原子条件更新操作的类。 
- 类 AtomicBoolean、AtomicInteger、AtomicLong 和 AtomicReference 的实例各自提供对 相应类型单个变量的访问和更新。每个类也为该类型提供适当的实用工具方法。 
- AtomicIntegerArray、AtomicLongArray 和 AtomicReferenceArray 类进一步扩展了原子操 作，对这些类型的数组提供了支持。这些类在为其数组元素提供 volatile 访问语义方 面也引人注目，这对于普通数组来说是不受支持的。 
- 核心方法：boolean compareAndSet(expectedValue, updateValue) 
- java.util.concurrent.atomic 包下提供了一些原子操作的常用类:
  - AtomicBoolean 、AtomicInteger 、AtomicLong 、 AtomicReference 
  - AtomicIntegerArray 、AtomicLongArray 
  - AtomicMarkableReference 
  - AtomicReferenceArray 
  - AtomicStampedReference 



## 参考

 http://tutorials.jenkov.com/java-concurrency/java-memory-model.html 

 https://juejin.im/post/5dbfa0aa51882538ce1a4ebc 