{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{587:function(t,s,e){\"use strict\";e.r(s);var v=e(4),_=Object(v.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[e(\"h2\",{attrs:{id:\"redis的五种基本数据类型\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#redis的五种基本数据类型\"}},[t._v(\"#\")]),t._v(\" Redis的五种基本数据类型\")]),t._v(\" \"),e(\"p\",[t._v(\"由于 Redis 是基于标准 C 写的，只有最基础的数据类型，因此 Redis 为了满足对外使用的 5 种数据类型，开发了属于自己\"),e(\"strong\",[t._v(\"独有的一套基础数据结构\")]),t._v(\"，使用这些数据结构来实现5种数据类型。\")]),t._v(\" \"),e(\"p\",[e(\"strong\",[t._v(\"Redis\")]),t._v(\" 有 5 种基础数据结构，它们分别是：\"),e(\"strong\",[t._v(\"string(字符串)\")]),t._v(\"、\"),e(\"strong\",[t._v(\"list(列表)\")]),t._v(\"、\"),e(\"strong\",[t._v(\"hash(字典)\")]),t._v(\"、\"),e(\"strong\",[t._v(\"set(集合)\")]),t._v(\" 和 \"),e(\"strong\",[t._v(\"zset(有序集合)\")]),t._v(\"。\")]),t._v(\" \"),e(\"p\",[t._v(\"Redis底层的数据结构包括：\"),e(\"strong\",[t._v(\"简单动态数组SDS、链表、字典、跳跃链表、整数集合、压缩列表、对象。\")])]),t._v(\" \"),e(\"p\",[t._v(\"Redis 为了平衡空间和时间效率，针对 value 的具体类型在底层会采用不同的数据结构来实现，其中哈希表和压缩列表是复用比较多的数据结构，如下图展示了对外数据类型和底层数据结构之间的映射关系：\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://tva1.sinaimg.cn/large/007S8ZIlly1ge0k8do3s3j30im0el7aa.jpg\",alt:\"\"}})]),t._v(\" \"),e(\"blockquote\",[e(\"p\",[t._v(\"安装好 Redis，我们可以使用 \"),e(\"code\",[t._v(\"redis-cli\")]),t._v(\" 来对 Redis 进行命令行的操作，当然 Redis 官方也提供了在线的调试器，你也可以在里面敲入命令进行操作：http://try.redis.io/#run\")])]),t._v(\" \"),e(\"h3\",{attrs:{id:\"_1、string-字符串\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1、string-字符串\"}},[t._v(\"#\")]),t._v(\" 1、String（字符串）\")]),t._v(\" \"),e(\"p\",[t._v(\"String 是 Redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。\")]),t._v(\" \"),e(\"p\",[t._v(\"String 类型是二进制安全的。意思是 Redis 的 String 可以包含任何数据。比如 jpg 图片或者序列化的对象 。\")]),t._v(\" \"),e(\"p\",[t._v(\"Redis 的字符串是动态字符串，是可以修改的字符串，\"),e(\"strong\",[t._v(\"内部结构实现上类似于 Java 的 ArrayList\")]),t._v(\"，采用预分配冗余空间的方式来减少内存的频繁分配，如图中所示，内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度 len。当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是字符串最大长度为 512M。\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"http://ww1.sinaimg.cn/large/9b9f09a9ly1g9ypoobef5j20fw04pq2p.jpg\",alt:\"redis-string.jpg\"}})]),t._v(\" \"),e(\"p\",[t._v(\"Redis 没有直接使用 C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称 C 字符串）， 而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型， 并将 SDS 用作 Redis 的默认字符串表示。\")]),t._v(\" \"),e(\"p\",[t._v(\"根据传统， C 语言使用长度为 \"),e(\"code\",[t._v(\"N+1\")]),t._v(\" 的字符数组来表示长度为 \"),e(\"code\",[t._v(\"N\")]),t._v(\" 的字符串， 并且字符数组的最后一个元素总是空字符 \"),e(\"code\",[t._v(\"'\\\\0'\")]),t._v(\" 。\")]),t._v(\" \"),e(\"p\",[t._v(\"比如说， 图 2-3 就展示了一个值为 \"),e(\"code\",[t._v('\"Redis\"')]),t._v(\" 的 C 字符串：\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"http://redisbook.com/_images/graphviz-cd9ca0391fd6ab95a2c5b48d5f5fbd0da2db1cab.png\",alt:\"\"}})]),t._v(\" \"),e(\"p\",[t._v(\"C 语言使用的这种简单的字符串表示方式， 并不能满足 Redis 对字符串在安全性、效率、以及功能方面的要求\")]),t._v(\" \"),e(\"p\",[e(\"a\",{attrs:{href:\"http://redisbook.com/preview/sds/different_between_sds_and_c_string.html\",title:\"SDS 与 C 字符串的区别\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"下面说明 SDS 比 C 字符串更适用于 Redis 的原因\"),e(\"OutboundLink\")],1),t._v(\"：\")]),t._v(\" \"),e(\"ul\",[e(\"li\",[e(\"p\",[e(\"strong\",[t._v(\"常数复杂度获取字符串长度\")])]),t._v(\" \"),e(\"p\",[t._v(\"因为 C 字符串并不记录自身的长度信息， 所以为了获取一个 C 字符串的长度， 程序必须遍历整个字符串，对遇到的每个字符进行计数， 直到遇到代表字符串结尾的空字符为止， 这个操作的复杂度为 O(N)\")]),t._v(\" \"),e(\"p\",[t._v(\"和 C 字符串不同， 因为 SDS 在 \"),e(\"code\",[t._v(\"len\")]),t._v(\" 属性中记录了 SDS 本身的长度， 所以获取一个 SDS 长度的复杂度仅为 O(1)\")]),t._v(\" \"),e(\"p\",[t._v(\"举个例子， 对于图 2-5 所示的 SDS 来说， 程序只要访问 SDS 的 \"),e(\"code\",[t._v(\"len\")]),t._v(\" 属性， 就可以立即知道 SDS 的长度为 \"),e(\"code\",[t._v(\"5\")]),t._v(\" 字节：\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"http://redisbook.com/_images/graphviz-dbd2f4d49a9f495f18093129393569f93e645529.png\",alt:\"\"}})]),t._v(\" \"),e(\"p\",[t._v(\"通过使用 SDS 而不是 C 字符串， Redis 将获取字符串长度所需的复杂度从 O(N) 降低到了 O(1) ， 这确保了获取字符串长度的工作不会成为 Redis 的性能瓶颈\")])]),t._v(\" \"),e(\"li\",[e(\"p\",[e(\"strong\",[t._v(\"缓冲区溢出/内存泄漏\")])]),t._v(\" \"),e(\"p\",[t._v(\"跟上述问题原因一样，如果执行拼接 or 缩短字符串的操作，如果操作不当就很容易造成上述问题；\")])]),t._v(\" \"),e(\"li\",[e(\"p\",[e(\"strong\",[t._v(\"减少修改字符串带来的内存分配次数\")])]),t._v(\" \"),e(\"p\",[t._v(\"因为 C 字符串并不记录自身的长度， 所以对于一个包含了 \"),e(\"code\",[t._v(\"N\")]),t._v(\" 个字符的 C 字符串来说， 这个 C 字符串的底层实现总是一个 \"),e(\"code\",[t._v(\"N+1\")]),t._v(\" 个字符长的数组（额外的一个字符空间用于保存空字符）。\")]),t._v(\" \"),e(\"p\",[t._v(\"因为 C 字符串的长度和底层数组的长度之间存在着这种关联性， 所以每次增长或者缩短一个 C 字符串， 程序都总要对保存这个 C 字符串的数组进行一次内存重分配操作：\")]),t._v(\" \"),e(\"ul\",[e(\"li\",[t._v(\"如果程序执行的是增长字符串的操作， 比如拼接操作（append）， 那么在执行这个操作之前， 程序需要先通过内存重分配来扩展底层数组的空间大小 —— 如果忘了这一步就会产生缓冲区溢出。\")]),t._v(\" \"),e(\"li\",[t._v(\"如果程序执行的是缩短字符串的操作， 比如截断操作（trim）， 那么在执行这个操作之后， 程序需要通过内存重分配来释放字符串不再使用的那部分空间 —— 如果忘了这一步就会产生内存泄漏。\")])]),t._v(\" \"),e(\"p\",[t._v(\"为了避免 C 字符串的这种缺陷， SDS 通过未使用空间解除了字符串长度和底层数组长度之间的关联： 在 SDS 中， \"),e(\"code\",[t._v(\"buf\")]),t._v(\" 数组的长度不一定就是字符数量加一， 数组里面可以包含未使用的字节， 而这些字节的数量就由 SDS 的 \"),e(\"code\",[t._v(\"free\")]),t._v(\" 属性记录。\")]),t._v(\" \"),e(\"p\",[t._v(\"通过未使用空间， SDS 实现了空间预分配和惰性空间释放两种优化策略。\")])]),t._v(\" \"),e(\"li\",[e(\"p\",[e(\"strong\",[t._v(\"二进制安全\")])]),t._v(\" \"),e(\"p\",[t._v(\"因为 C 语言中的字符串必须符合某种编码（比如 ASCII），并且除了字符串的末尾之外， 字符串里面不能包含空字符， 否则最先被程序读入的空字符将被误认为是字符串结尾 —— 这些限制使得 C 字符串只能保存文本数据， 而不能保存像图片、音频、视频、压缩文件这样的二进制数据\")])])]),t._v(\" \"),e(\"h3\",{attrs:{id:\"_2、list-列表\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2、list-列表\"}},[t._v(\"#\")]),t._v(\" 2、List（列表）\")]),t._v(\" \"),e(\"p\",[e(\"strong\",[t._v(\"Redis 的列表相当于 Java 语言里面的 LinkedList，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)\")])]),t._v(\" \"),e(\"p\",[t._v(\"当列表弹出了最后一个元素之后，该数据结构自动被删除，内存被回收。\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2018/7/2/1645918c2cdf772e?imageslim\",alt:\"img\"}})]),t._v(\" \"),e(\"p\",[t._v(\"Redis 的列表结构常用来做异步队列使用。将需要延后处理的任务结构体序列化成字符串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理\")]),t._v(\" \"),e(\"p\",[e(\"strong\",[t._v(\"右边进左边出：队列\")])]),t._v(\" \"),e(\"div\",{staticClass:\"language-shell extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-shell\"}},[e(\"code\",[e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" rpush books python java golang \\n\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"integer\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"3\")]),t._v(\" \\n\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"\\\\\")]),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" llen books\\n \"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"integer\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"3\")]),t._v(\" \\n\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"\\\\\")]),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" lpop books\\n \"),e(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"python\"')]),t._v(\" \\n\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"\\\\\")]),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" lpop books\\n \"),e(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"java\"')]),t._v(\" \\n\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"\\\\\")]),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" lpop books \\n\"),e(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"golang\"')]),t._v(\" \\n\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"\\\\\")]),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" lpop books \\n\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"nil\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n\")])])]),e(\"p\",[e(\"strong\",[t._v(\"右边进右边出：栈\")])]),t._v(\" \"),e(\"div\",{staticClass:\"language-shell extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-shell\"}},[e(\"code\",[e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" rpush books python java golang\\n \"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"integer\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"3\")]),t._v(\"\\n \"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"\\\\\")]),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" rpop books \\n\"),e(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"golang\"')]),t._v(\" \\n\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"\\\\\")]),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" rpop books \\n\"),e(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"java\"')]),t._v(\" \\n\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"\\\\\")]),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" rpop books \\n\"),e(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"python\"')]),t._v(\"\\n \"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"\\\\\")]),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" rpop books\\n \"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"nil\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n\")])])]),e(\"h4\",{attrs:{id:\"列表的实现\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#列表的实现\"}},[t._v(\"#\")]),t._v(\" \"),e(\"a\",{attrs:{href:\"http://redisbook.com/preview/adlist/implementation.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"列表的实现\"),e(\"OutboundLink\")],1)]),t._v(\" \"),e(\"p\",[t._v(\"我们可以从 \"),e(\"a\",{attrs:{href:\"https://github.com/redis/redis/blob/unstable/src/adlist.h\",title:\"redis源码\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"源码\"),e(\"OutboundLink\")],1),t._v(\" 的 \"),e(\"code\",[t._v(\"adlist.h/listNode\")]),t._v(\" 来看到对其的定义：\")]),t._v(\" \"),e(\"div\",{staticClass:\"language-c extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-c\"}},[e(\"code\",[e(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"/* Node, List, and Iterator are the only data structures used currently. */\")]),t._v(\"\\n\\n\"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"typedef\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"listNode\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"listNode\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"prev\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 前置节点\")]),t._v(\"\\n    \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"listNode\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"next\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 后置节点\")]),t._v(\"\\n    \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"value\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"           \"),e(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 节点的值\")]),t._v(\"\\n\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\" listNode\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\\n\"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"typedef\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"listIter\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    listNode \"),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"next\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n    \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"int\")]),t._v(\" direction\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\" listIter\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\\n\"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"typedef\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"list\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    listNode \"),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"head\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\\t\"),e(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 表头节点\")]),t._v(\"\\n    listNode \"),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"tail\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\\t\"),e(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 表尾节点\")]),t._v(\"\\n    \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"dup\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"ptr\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\"),e(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 节点值复制函数\")]),t._v(\"\\n    \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"free\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"ptr\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\"),e(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 节点值释放函数\")]),t._v(\"\\n    \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"int\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"match\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"ptr\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"key\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\"),e(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 节点值对比函数\")]),t._v(\"\\n    \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"unsigned\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"long\")]),t._v(\" len\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\"),e(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 链表所包含的节点数量\")]),t._v(\"\\n\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\" list\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\")])])]),e(\"p\",[t._v(\"对于 Javaer 我认为知道底层是个\"),e(\"strong\",[t._v(\"双端链表\")]),t._v(\"就够了，如果再深入一点，你会发现 Redis 底层存储的还不是一个简单的 \"),e(\"code\",[t._v(\"linkedlist\")]),t._v(\"，而是称之为快速链表 \"),e(\"code\",[t._v(\"quicklist\")]),t._v(\" 的一个结构。\")]),t._v(\" \"),e(\"h3\",{attrs:{id:\"_3、hash-字典\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3、hash-字典\"}},[t._v(\"#\")]),t._v(\" 3、Hash（字典）\")]),t._v(\" \"),e(\"p\",[t._v(\"Redis hash 是一个键值对集合。KV 模式不变，但 V 是一个键值对。\")]),t._v(\" \"),e(\"p\",[t._v(\"Redis 的字典相当于 Java 语言里面的 HashMap，它是无序字典， 内部实现结构上同 Java 的 HashMap 也是一致的，同样的\"),e(\"strong\",[t._v(\"数组 + 链表\")]),t._v(\"二维结构。第一维 hash 的数组位置碰撞时，就会将碰撞的元素使用链表串接起来。\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"http://ww1.sinaimg.cn/large/9b9f09a9ly1g9ypp2rs05j20g307pa9u.jpg\",alt:\"redis-hash.jpg\"}})]),t._v(\" \"),e(\"p\",[t._v(\"不同的是，Redis 的字典的值只能是字符串，另外它们 rehash 的方式不一样，因为 Java 的 HashMap 在字典很大时，rehash 是个耗时的操作，需要一次性全部 rehash。Redis 为了高性能，不能堵塞服务，所以采用了渐进式 rehash 策略。\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2018/7/28/164dc873b2a899a8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\",alt:\"img\"}})]),t._v(\" \"),e(\"p\",[t._v(\"渐进式 rehash 会在 rehash 的同时，保留新旧两个 hash 结构，查询时会同时查询两个 hash 结构，然后在后续的定时任务中以及 hash 操作指令中，循序渐进地将旧 hash 的内容一点点迁移到新的 hash 结构中。当搬迁完成了，就会使用新的hash结构取而代之。\")]),t._v(\" \"),e(\"p\",[t._v(\"当 hash 移除了最后一个元素之后，该数据结构自动被删除，内存被回收。\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2018/7/2/16458ef82907e5e1?imageslim\",alt:\"img\"}})]),t._v(\" \"),e(\"p\",[t._v(\"hash 结构也可以用来存储用户信息，不同于字符串一次性需要全部序列化整个对象，hash 可以对用户结构中的每个字段单独存储。这样当我们需要获取用户信息时可以进行部分获取。而以整个字符串的形式去保存用户信息的话就只能一次性全部读取，这样就会比较浪费网络流量。\")]),t._v(\" \"),e(\"p\",[t._v(\"hash 也有缺点，hash 结构的存储消耗要高于单个字符串，到底该使用 hash 还是字符串，需要根据实际情况再三权衡。\")]),t._v(\" \"),e(\"h4\",{attrs:{id:\"字典的实现\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#字典的实现\"}},[t._v(\"#\")]),t._v(\" \"),e(\"a\",{attrs:{href:\"http://redisbook.com/preview/dict/datastruct.html\",title:\"字典的实现\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"字典的实现\"),e(\"OutboundLink\")],1)]),t._v(\" \"),e(\"p\",[t._v(\"Redis 字典源码由 \"),e(\"code\",[t._v(\"dict.h/dictht\")]),t._v(\" 结构定义：\")]),t._v(\" \"),e(\"div\",{staticClass:\"language-c extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-c\"}},[e(\"code\",[e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"typedef\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"dictEntry\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"key\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n    \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"union\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n        \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"val\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n        uint64_t u64\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n        int64_t s64\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n        \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"double\")]),t._v(\" d\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n    \"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\" v\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n    \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"dictEntry\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"next\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\" dictEntry\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\\n\"),e(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"/* This is our hash table structure. Every dictionary has two of this as we\\n * implement incremental rehashing, for the old to the new table. */\")]),t._v(\"\\n\"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"typedef\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"dictht\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    dictEntry \"),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"table\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" \\t\\t\"),e(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 哈希表数组\")]),t._v(\"\\n    \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"unsigned\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"long\")]),t._v(\" size\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\\t\"),e(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 哈希表大小\")]),t._v(\"\\n    \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"unsigned\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"long\")]),t._v(\" sizemask\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\"),e(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 哈希表大小掩码，用于计算索引值,总是等于 size - 1\")]),t._v(\"\\n    \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"unsigned\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"long\")]),t._v(\" used\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\\t\"),e(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 该哈希表已有节点的数量\")]),t._v(\"\\n\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\" dictht\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\\n\"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"typedef\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"dict\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    dictType \"),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"type\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t \"),e(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 类型特定函数\")]),t._v(\"\\n    \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"privdata\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 私有数据 \")]),t._v(\"\\n    dictht ht\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"[\")]),e(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"2\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"]\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\"),e(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 哈希表\")]),t._v(\"\\n\\t\"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"long\")]),t._v(\" rehashidx\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"/* rehashing not in progress if rehashidx == -1 */\")]),t._v(\"\\n    \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"unsigned\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"long\")]),t._v(\" iterators\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"/* number of iterators currently running */\")]),t._v(\"\\n\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\" dict\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\")])])]),e(\"h3\",{attrs:{id:\"_4、set-集合\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4、set-集合\"}},[t._v(\"#\")]),t._v(\" 4、Set（集合）\")]),t._v(\" \"),e(\"p\",[t._v(\"Redis 的 Set 是 String 类型的无序集合。它是通过 HashTable 实现的， 相当于 Java 语言里面的 HashSet，它内部的键值对是无序的唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值\"),e(\"code\",[t._v(\"NULL\")]),t._v(\"。\")]),t._v(\" \"),e(\"p\",[t._v(\"当集合中最后一个元素移除之后，数据结构自动删除，内存被回收。\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2018/7/2/16458e2da04f1a2d?imageslim\",alt:\"img\"}})]),t._v(\" \"),e(\"h3\",{attrs:{id:\"_5、zset-sorted-set-有序集合\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5、zset-sorted-set-有序集合\"}},[t._v(\"#\")]),t._v(\" 5、zset(sorted set：有序集合)\")]),t._v(\" \"),e(\"p\",[t._v(\"zset 和 set 一样也是 String 类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。\")]),t._v(\" \"),e(\"p\",[t._v(\"Redis 正是通过分数来为集合中的成员进行从小到大的排序。zset 的成员是唯一的，但分数(score)却可以重复。\")]),t._v(\" \"),e(\"p\",[t._v(\"它类似于 Java 的 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的排序权重。它的内部实现用的是一种叫做「\"),e(\"strong\",[t._v(\"跳跃列表\")]),t._v(\"」的数据结构。\")]),t._v(\" \"),e(\"p\",[t._v(\"zset 中最后一个 value 被移除后，数据结构自动删除，内存被回收。\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2018/7/2/16458f9f679a8bb0?imageslim\",alt:\"img\"}})]),t._v(\" \"),e(\"h2\",{attrs:{id:\"redis常见数据类型查阅\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#redis常见数据类型查阅\"}},[t._v(\"#\")]),t._v(\" Redis常见数据类型查阅：\")]),t._v(\" \"),e(\"p\",[e(\"a\",{attrs:{href:\"http://www.redis.cn/commands.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"Redis命令中心\"),e(\"OutboundLink\")],1)]),t._v(\" \"),e(\"h4\",{attrs:{id:\"key-键-常用命令\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#key-键-常用命令\"}},[t._v(\"#\")]),t._v(\" Key（键）常用命令\")]),t._v(\" \"),e(\"table\",[e(\"thead\",[e(\"tr\",[e(\"th\",[t._v(\"命令\")]),t._v(\" \"),e(\"th\",[t._v(\"用法\")]),t._v(\" \"),e(\"th\",[t._v(\"描述\")]),t._v(\" \"),e(\"th\",[t._v(\"示例\")])])]),t._v(\" \"),e(\"tbody\",[e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"DEL\")])]),t._v(\" \"),e(\"td\",[t._v(\"DEL key [key ...]\")]),t._v(\" \"),e(\"td\",[t._v(\"删除给定的一个或多个 key。 不存在的 key 会被忽略\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"DUMP\")]),t._v(\" \"),e(\"td\",[t._v(\"DUMP key\")]),t._v(\" \"),e(\"td\",[t._v(\"序列化给定 key ，并返回被序列化的值，使用 RESTORE 命令可以将这个值反序列化为 Redis 键\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"EXISTS\")]),t._v(\" \"),e(\"td\",[t._v(\"EXISTS key\")]),t._v(\" \"),e(\"td\",[t._v(\"检查给定 key 是否存在\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"EXPIRE\")])]),t._v(\" \"),e(\"td\",[t._v(\"EXPIRE key seconds\")]),t._v(\" \"),e(\"td\",[t._v(\"为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"PERSIST\")])]),t._v(\" \"),e(\"td\",[t._v(\"PERSIST key\")]),t._v(\" \"),e(\"td\",[t._v(\"移除 key 的过期时间，key 将持久保持。\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"EXPIREAT\")])]),t._v(\" \"),e(\"td\",[t._v(\"EXPIREAT key timestamp\")]),t._v(\" \"),e(\"td\",[t._v(\"EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置生存时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)\")]),t._v(\" \"),e(\"td\",[t._v(\"EXPIREAT cache 1355292000     # 这个 key 将在 2012.12.12 过期\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"KEYS\")])]),t._v(\" \"),e(\"td\",[t._v(\"KEYS pattern\")]),t._v(\" \"),e(\"td\",[t._v(\"查找所有符合给定模式 pattern 的 key\")]),t._v(\" \"),e(\"td\",[t._v(\"KEYS *  # 匹配数据库内所有 key\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"MOVE\")]),t._v(\" \"),e(\"td\",[t._v(\"MOVE key db\")]),t._v(\" \"),e(\"td\",[t._v(\"将当前数据库的 key 移动到给定的数据库 db 当中如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 key ，或者 key 不存在于当前数据库，那么 MOVE 没有任何效果。 因此，也可以利用这一特性，将 MOVE 当作锁(locking)原语(primitive)\")]),t._v(\" \"),e(\"td\",[t._v(\"MOVE song 1                          # 将 song 移动到数据库 1\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"TTL\")])]),t._v(\" \"),e(\"td\",[t._v(\"TTL key\")]),t._v(\" \"),e(\"td\",[t._v(\"以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)当 key 不存在时，返回 -2 。当 key 存在但没有设置剩余生存时间时，返回 -1 。否则，以秒为单位，返回 key 的剩余生存时间\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"PTTL\")]),t._v(\" \"),e(\"td\",[t._v(\"PTTL key\")]),t._v(\" \"),e(\"td\",[t._v(\"以毫秒为单位返回 key 的剩余的过期时间。\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"TYPE\")])]),t._v(\" \"),e(\"td\",[t._v(\"TYPE key\")]),t._v(\" \"),e(\"td\",[t._v(\"返回 key 所储存的值的类型\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"RENAME\")]),t._v(\" \"),e(\"td\",[t._v(\"RENAME key newkey\")]),t._v(\" \"),e(\"td\",[t._v(\"将 key 改名为 newkey 。当 key 和 newkey 相同，或者 key 不存在时，返回一个错误。当 newkey 已经存在时， RENAME 命令将覆盖旧值\")]),t._v(\" \"),e(\"td\")])])]),t._v(\" \"),e(\"h4\",{attrs:{id:\"string-字符串-常用命令\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#string-字符串-常用命令\"}},[t._v(\"#\")]),t._v(\" String （字符串）常用命令\")]),t._v(\" \"),e(\"table\",[e(\"thead\",[e(\"tr\",[e(\"th\",[t._v(\"命令\")]),t._v(\" \"),e(\"th\",[t._v(\"用法\")]),t._v(\" \"),e(\"th\",[t._v(\"描述\")]),t._v(\" \"),e(\"th\",[t._v(\"示例\")])])]),t._v(\" \"),e(\"tbody\",[e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"SET\")])]),t._v(\" \"),e(\"td\",[t._v(\"SET key value [EX seconds] [PX milliseconds] [NX|XX]\")]),t._v(\" \"),e(\"td\",[t._v(\"将字符串值 value 关联到 key 。如果 key 已经持有其他值， SET 就覆写旧值，无视类型\")]),t._v(\" \"),e(\"td\",[t._v('SET key \"value\"')])]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"MSET\")])]),t._v(\" \"),e(\"td\",[t._v(\"MSET key value [key value ...]\")]),t._v(\" \"),e(\"td\",[t._v(\"同时设置一个或多个 key-value 对。如果某个给定 key 已经存在，那么 MSET 会用新值覆盖原来的旧值，如果这不是你所希望的效果，请考虑使用 MSETNX 命令：它只会在所有给定 key 都不存在的情况下进行设置操作\")]),t._v(\" \"),e(\"td\",[t._v('MSET date \"2012.3.30\" time \"11:00 a.m.\" weather \"sunny\"')])]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"SETNX\")])]),t._v(\" \"),e(\"td\",[t._v(\"SETNX key value\")]),t._v(\" \"),e(\"td\",[t._v(\"将 key 的值设为 value ，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作 SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"MSETNX\")]),t._v(\" \"),e(\"td\",[t._v(\"MSETNX key value [key value ...]\")]),t._v(\" \"),e(\"td\",[t._v(\"同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。即使只有一个给定 key 已存在， MSETNX 也会拒绝执行所有给定 key 的设置操作\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"SETRANGE\")]),t._v(\" \"),e(\"td\",[t._v(\"SETRANGE key offset value\")]),t._v(\" \"),e(\"td\",[t._v(\"用 value 参数覆写(overwrite)给定 key 所储存的字符串值，从偏移量 offset 开始。不存在的 key 当作空白字符串处理\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"SETBIT\")]),t._v(\" \"),e(\"td\",[t._v(\"SETBIT key offset value\")]),t._v(\" \"),e(\"td\",[t._v(\"对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)\")]),t._v(\" \"),e(\"td\",[t._v(\"GETBIT bit 100   # bit 默认被初始化为 0\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"SETEX\")]),t._v(\" \"),e(\"td\",[t._v(\"SETEX key seconds value\")]),t._v(\" \"),e(\"td\",[t._v(\"将值 value 关联到 key ，并将 key 的生存时间设为 seconds (以秒为单位)。如果 key 已经存在， SETEX 命令将覆写旧值。\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"PSETEX\")]),t._v(\" \"),e(\"td\",[t._v(\"PSETEX key milliseconds value\")]),t._v(\" \"),e(\"td\",[t._v(\"这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"STRLEN\")]),t._v(\" \"),e(\"td\",[t._v(\"STRLEN key\")]),t._v(\" \"),e(\"td\",[t._v(\"返回 key 所储存的字符串值的长度。当 key 储存的不是字符串值时，返回一个错误\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"GET\")])]),t._v(\" \"),e(\"td\",[t._v(\"GET key\")]),t._v(\" \"),e(\"td\",[t._v(\"返回 key 所关联的字符串值。如果 key 不存在那么返回特殊值 nil\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"MGET\")])]),t._v(\" \"),e(\"td\",[t._v(\"MGET key [key ...]\")]),t._v(\" \"),e(\"td\",[t._v(\"返回所有(一个或多个)给定 key 的值。如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil 。因此，该命令永不失败\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"GETRANGE\")]),t._v(\" \"),e(\"td\",[t._v(\"GETRANGE key start end\")]),t._v(\" \"),e(\"td\",[t._v(\"返回 key 中字符串值的子字符串，字符串的截取范围由 start 和 end 两个偏移量决定(包括 start 和 end 在内)。负数偏移量表示从字符串最后开始计数， -1 表示最后一个字符， -2 表示倒数第二个，以此类推。\")]),t._v(\" \"),e(\"td\",[t._v(\"GETRANGE greeting 0 4\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"GETSET\")]),t._v(\" \"),e(\"td\",[t._v(\"GETSET key value\")]),t._v(\" \"),e(\"td\",[t._v(\"将给定 key 的值设为 value ，并返回 key 的旧值(old value)。当 key 存在但不是字符串类型时，返回一个错误。\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"GETBIT\")]),t._v(\" \"),e(\"td\",[t._v(\"GETBIT key offset\")]),t._v(\" \"),e(\"td\",[t._v(\"对 key 所储存的字符串值，获取指定偏移量上的位(bit)。当 offset 比字符串值的长度大，或者 key 不存在时，返回 0\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"APPEND\")])]),t._v(\" \"),e(\"td\",[t._v(\"APPEND key value\")]),t._v(\" \"),e(\"td\",[t._v(\"如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。如果 key 不存在， APPEND 就简单地将给定 key 设为 value ，就像执行 SET key value 一样\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"DECR\")])]),t._v(\" \"),e(\"td\",[t._v(\"DECR key\")]),t._v(\" \"),e(\"td\",[t._v(\"将 key 中储存的数字值减一。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECR 操作\")]),t._v(\" \"),e(\"td\",[t._v(\"redis> SET failure_times 10OK redis> DECR failure_times(integer) 9\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"DECRBY\")])]),t._v(\" \"),e(\"td\",[t._v(\"DECRBY key decrement\")]),t._v(\" \"),e(\"td\",[t._v(\"将 key 所储存的值减去减量 decrement\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"INCR\")])]),t._v(\" \"),e(\"td\",[t._v(\"INCR key\")]),t._v(\" \"),e(\"td\",[t._v(\"将 key 中储存的数字值增一。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"INCRBY\")])]),t._v(\" \"),e(\"td\",[t._v(\"INCRBY key increment\")]),t._v(\" \"),e(\"td\",[t._v(\"将 key 所储存的值加上增量 increment\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"INCRBYFLOAT\")]),t._v(\" \"),e(\"td\",[t._v(\"INCRBYFLOAT key increment\")]),t._v(\" \"),e(\"td\",[t._v(\"为 key 中所储存的值加上浮点数增量 increment\")]),t._v(\" \"),e(\"td\",[t._v(\"INCRBYFLOAT mykey 0.1\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"BITCOUNT\")]),t._v(\" \"),e(\"td\",[t._v(\"BITCOUNT key [start] [end]\")]),t._v(\" \"),e(\"td\",[t._v(\"计算给定字符串中，被设置为 1 的比特位的数量\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"BITOP\")]),t._v(\" \"),e(\"td\",[t._v(\"BITOP operation destkey key [key ...]\")]),t._v(\" \"),e(\"td\",[t._v(\"对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。\")]),t._v(\" \"),e(\"td\")])])]),t._v(\" \"),e(\"h4\",{attrs:{id:\"list-列表-常用命令\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#list-列表-常用命令\"}},[t._v(\"#\")]),t._v(\" List（列表）常用命令\")]),t._v(\" \"),e(\"table\",[e(\"thead\",[e(\"tr\",[e(\"th\",[t._v(\"命令\")]),t._v(\" \"),e(\"th\",[t._v(\"用法\")]),t._v(\" \"),e(\"th\",[t._v(\"描述\")]),t._v(\" \"),e(\"th\",[t._v(\"示例\")])])]),t._v(\" \"),e(\"tbody\",[e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"LPUSH\")])]),t._v(\" \"),e(\"td\",[t._v(\"LPUSH key value [value ...]\")]),t._v(\" \"),e(\"td\",[t._v(\"将一个或多个值 value 插入到列表 key 的表头如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表头\")]),t._v(\" \"),e(\"td\",[t._v(\"正着进反着出\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"LPUSHX\")]),t._v(\" \"),e(\"td\",[t._v(\"LPUSHX key value\")]),t._v(\" \"),e(\"td\",[t._v(\"将值 value 插入到列表 key 的表头，当且仅当 key 存在并且是一个列表。和 LPUSH 命令相反，当 key 不存在时， LPUSHX 命令什么也不做\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"RPUSH\")])]),t._v(\" \"),e(\"td\",[t._v(\"RPUSH key value [value ...]\")]),t._v(\" \"),e(\"td\",[t._v(\"将一个或多个值 value 插入到列表 key 的表尾(最右边)\")]),t._v(\" \"),e(\"td\",[t._v(\"怎么进怎么出\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"RPUSHX\")]),t._v(\" \"),e(\"td\",[t._v(\"RPUSHX key value\")]),t._v(\" \"),e(\"td\",[t._v(\"将值 value 插入到列表 key 的表尾，当且仅当 key 存在并且是一个列表。和 RPUSH 命令相反，当 key 不存在时， RPUSHX 命令什么也不做。\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"LPOP\")])]),t._v(\" \"),e(\"td\",[t._v(\"LPOP key\")]),t._v(\" \"),e(\"td\",[t._v(\"移除并返回列表 key 的头元素。\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"BLPOP\")])]),t._v(\" \"),e(\"td\",[t._v(\"BLPOP key [key ...] timeout\")]),t._v(\" \"),e(\"td\",[t._v(\"移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"RPOP\")])]),t._v(\" \"),e(\"td\",[t._v(\"RPOP key\")]),t._v(\" \"),e(\"td\",[t._v(\"移除并返回列表 key 的尾元素。\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"BRPOP\")])]),t._v(\" \"),e(\"td\",[t._v(\"BRPOP key [key ...] timeout\")]),t._v(\" \"),e(\"td\",[t._v(\"移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"BRPOPLPUSH\")]),t._v(\" \"),e(\"td\",[t._v(\"BRPOPLPUSH source destination timeout\")]),t._v(\" \"),e(\"td\",[t._v(\"从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"RPOPLPUSH\")]),t._v(\" \"),e(\"td\",[t._v(\"RPOPLPUSH source destinationb\")]),t._v(\" \"),e(\"td\",[t._v(\"命令 RPOPLPUSH 在一个原子时间内，执行以下两个动作：将列表 source 中的最后一个元素(尾元素)弹出，并返回给客户端。将 source 弹出的元素插入到列表 destination ，作为 destination 列表的的头元素\")]),t._v(\" \"),e(\"td\",[t._v(\"RPOPLPUSH list01 list02\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"LSET\")])]),t._v(\" \"),e(\"td\",[t._v(\"LSET key index value\")]),t._v(\" \"),e(\"td\",[t._v(\"将列表 key 下标为 index 的元素的值设置为 value\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"LLEN\")])]),t._v(\" \"),e(\"td\",[t._v(\"LLEN key\")]),t._v(\" \"),e(\"td\",[t._v(\"返回列表 key 的长度。如果 key 不存在，则 key 被解释为一个空列表，返回 0 .如果 key 不是列表类型，返回一个错误\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"LINDEX\")])]),t._v(\" \"),e(\"td\",[t._v(\"LINDEX key index\")]),t._v(\" \"),e(\"td\",[t._v(\"返回列表 key 中，下标为 index 的元素。下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。相当于 Java 链表的\"),e(\"code\",[t._v(\"get(int index)\")]),t._v(\"方法，它需要对链表进行遍历，性能随着参数\"),e(\"code\",[t._v(\"index\")]),t._v(\"增大而变差。\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"LRANGE\")])]),t._v(\" \"),e(\"td\",[t._v(\"LRANGE key start stop\")]),t._v(\" \"),e(\"td\",[t._v(\"返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"LREM\")]),t._v(\" \"),e(\"td\",[t._v(\"LREM key count value\")]),t._v(\" \"),e(\"td\",[t._v(\"根据参数 count 的值，移除列表中与参数 value 相等的元素\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"LTRIM\")]),t._v(\" \"),e(\"td\",[t._v(\"LTRIM key start stop\")]),t._v(\" \"),e(\"td\",[t._v(\"对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"LINSERT\")]),t._v(\" \"),e(\"td\",[t._v(\"LINSERT key BEFORE|AFTER pivot value\")]),t._v(\" \"),e(\"td\",[t._v(\"将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。当 pivot 不存在于列表 key 时，不执行任何操作。当 key 不存在时， key 被视为空列表，不执行任何操作。如果 key 不是列表类型，返回一个错误。\")]),t._v(\" \"),e(\"td\",[t._v(\"LINSERT list01 before c++ c#(在c++之前加上C#)\")])])])]),t._v(\" \"),e(\"h4\",{attrs:{id:\"hash-哈希表-常用命令\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#hash-哈希表-常用命令\"}},[t._v(\"#\")]),t._v(\" \"),e(\"strong\",[t._v(\"Hash\")]),t._v(\"（哈希表）常用命令\")]),t._v(\" \"),e(\"table\",[e(\"thead\",[e(\"tr\",[e(\"th\",[t._v(\"命令\")]),t._v(\" \"),e(\"th\",[t._v(\"用法\")]),t._v(\" \"),e(\"th\",[t._v(\"描述\")]),t._v(\" \"),e(\"th\",[t._v(\"示例\")])])]),t._v(\" \"),e(\"tbody\",[e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"HSET\")])]),t._v(\" \"),e(\"td\",[t._v(\"HSET key field value\")]),t._v(\" \"),e(\"td\",[t._v(\"将哈希表 key 中的域 field 的值设为 value 。如果 key 不存在，一个新的哈希表被创建并进行 HSET 操作。如果域 field 已经存在于哈希表中，旧值将被覆盖。\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"HMSET\")])]),t._v(\" \"),e(\"td\",[t._v(\"HMSET key field value [field value ...]\")]),t._v(\" \"),e(\"td\",[t._v(\"同时将多个 field-value (域-值)对设置到哈希表 key 中。此命令会覆盖哈希表中已存在的域。\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"HSETNX\")])]),t._v(\" \"),e(\"td\",[t._v(\"HSETNX key field value\")]),t._v(\" \"),e(\"td\",[t._v(\"将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在。若域 field 已经存在，该操作无效\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"HGET\")])]),t._v(\" \"),e(\"td\",[t._v(\"HGET key field\")]),t._v(\" \"),e(\"td\",[t._v(\"返回哈希表 key 中给定域 field 的值\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"HMGET\")])]),t._v(\" \"),e(\"td\",[t._v(\"HMGET key field [field ...]\")]),t._v(\" \"),e(\"td\",[t._v(\"返回哈希表 key 中，一个或多个给定域的值。\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"HGETALL\")])]),t._v(\" \"),e(\"td\",[t._v(\"HGETALL key\")]),t._v(\" \"),e(\"td\",[t._v(\"返回哈希表 key 中，所有的域和值。在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"HDEL\")]),t._v(\" \"),e(\"td\",[t._v(\"HDEL key field [field ...]\")]),t._v(\" \"),e(\"td\",[t._v(\"删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"HEXISTS\")]),t._v(\" \"),e(\"td\",[t._v(\"HEXISTS key field\")]),t._v(\" \"),e(\"td\",[t._v(\"查看哈希表 key 中，给定域 field 是否存在\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"HLEN\")]),t._v(\" \"),e(\"td\",[t._v(\"HLEN key\")]),t._v(\" \"),e(\"td\",[t._v(\"返回哈希表 key 中域的数量\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"HKEYS\")])]),t._v(\" \"),e(\"td\",[t._v(\"HKEYS key\")]),t._v(\" \"),e(\"td\",[t._v(\"返回哈希表 key 中的所有域\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"HVALS\")])]),t._v(\" \"),e(\"td\",[t._v(\"HVALS key\")]),t._v(\" \"),e(\"td\",[t._v(\"返回哈希表 key 中所有域的值\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"HSTRLEN\")]),t._v(\" \"),e(\"td\",[t._v(\"HSTRLEN key field\")]),t._v(\" \"),e(\"td\",[t._v(\"返回哈希表 key 中，与给定域 field 相关联的值的字符串长度（string length）。如果给定的键或者域不存在，那么命令返回 0\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"HINCRBY\")]),t._v(\" \"),e(\"td\",[t._v(\"HINCRBY key field increment\")]),t._v(\" \"),e(\"td\",[t._v(\"为哈希表 key 中的域 field 的值加上增量 increment\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"HINCRBYFLOAT\")]),t._v(\" \"),e(\"td\",[t._v(\"HINCRBYFLOAT key field increment\")]),t._v(\" \"),e(\"td\",[t._v(\"为哈希表 key 中的域 field 加上浮点数增量 increment\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"HSCAN\")]),t._v(\" \"),e(\"td\",[t._v(\"HSCAN key cursor [MATCH pattern] [COUNT count]\")]),t._v(\" \"),e(\"td\",[t._v(\"迭代哈希表中的键值对。\")]),t._v(\" \"),e(\"td\")])])]),t._v(\" \"),e(\"h4\",{attrs:{id:\"set-集合-常用命令\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#set-集合-常用命令\"}},[t._v(\"#\")]),t._v(\" Set（集合）常用命令\")]),t._v(\" \"),e(\"table\",[e(\"thead\",[e(\"tr\",[e(\"th\",[t._v(\"命令\")]),t._v(\" \"),e(\"th\",[t._v(\"用法\")]),t._v(\" \"),e(\"th\",[t._v(\"描述\")]),t._v(\" \"),e(\"th\",[t._v(\"示例\")])])]),t._v(\" \"),e(\"tbody\",[e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"SADD\")])]),t._v(\" \"),e(\"td\",[t._v(\"SADD key member [member ...]\")]),t._v(\" \"),e(\"td\",[t._v(\"将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。假如 key 不存在，则创建一个只包含 member 元素作成员的集合。当 key 不是集合类型时，返回一个错误\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"SCARD\")])]),t._v(\" \"),e(\"td\",[t._v(\"SCARD key\")]),t._v(\" \"),e(\"td\",[t._v(\"返回集合 key 的基数(集合中元素的数量)。\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"SDIFF\")])]),t._v(\" \"),e(\"td\",[t._v(\"SDIFF key [key ...]\")]),t._v(\" \"),e(\"td\",[t._v(\"返回一个集合的全部成员，该集合是所有给定集合之间的差集。不存在的 key 被视为空集。\")]),t._v(\" \"),e(\"td\",[t._v(\"差集\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"SDIFFSTORE\")]),t._v(\" \"),e(\"td\",[t._v(\"SDIFFSTORE destination key [key ...]\")]),t._v(\" \"),e(\"td\",[t._v(\"这个命令的作用和 SDIFF 类似，但它将结果保存到 destination 集合，而不是简单地返回结果集。如果 destination 集合已经存在，则将其覆盖。destination 可以是 key 本身。\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"SINTER\")])]),t._v(\" \"),e(\"td\",[t._v(\"SINTER key [key ...]\")]),t._v(\" \"),e(\"td\",[t._v(\"返回一个集合的全部成员，该集合是所有给定集合的交集。不存在的 key 被视为空集。当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)\")]),t._v(\" \"),e(\"td\",[t._v(\"交集\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"SINTERSTORE\")]),t._v(\" \"),e(\"td\",[t._v(\"SINTERSTORE destination key [key ...]\")]),t._v(\" \"),e(\"td\",[t._v(\"这个命令类似于 SINTER 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。如果 destination 集合已经存在，则将其覆盖。destination 可以是 key 本身\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"SUNION\")])]),t._v(\" \"),e(\"td\",[t._v(\"SUNION key [key ...]\")]),t._v(\" \"),e(\"td\",[t._v(\"返回一个集合的全部成员，该集合是所有给定集合的并集。不存在的 key 被视为空集\")]),t._v(\" \"),e(\"td\",[t._v(\"并集\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"SUNIONSTORE\")]),t._v(\" \"),e(\"td\",[t._v(\"SUNIONSTORE destination key [key ...]\")]),t._v(\" \"),e(\"td\",[t._v(\"这个命令类似于 SUNION 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。如果 destination 已经存在，则将其覆盖。destination 可以是 key 本身\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"SMEMBERS\")])]),t._v(\" \"),e(\"td\",[t._v(\"SMEMBERS key\")]),t._v(\" \"),e(\"td\",[t._v(\"返回集合 key 中的所有成员。不存在的 key 被视为空集合\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"SRANDMEMBER\")]),t._v(\" \"),e(\"td\",[t._v(\"SRANDMEMBER key [count]\")]),t._v(\" \"),e(\"td\",[t._v(\"如果命令执行时，只提供了 key 参数，那么返回集合中的一个随机元素\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"SISMEMBER\")])]),t._v(\" \"),e(\"td\",[t._v(\"SISMEMBER key member\")]),t._v(\" \"),e(\"td\",[t._v(\"判断 member 元素是否集合 key 的成员\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"SMOVE\")]),t._v(\" \"),e(\"td\",[t._v(\"SMOVE source destination member\")]),t._v(\" \"),e(\"td\",[t._v(\"将 member 元素从 source 集合移动到 destination 集合。\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"SPOP\")]),t._v(\" \"),e(\"td\",[t._v(\"SPOP key\")]),t._v(\" \"),e(\"td\",[t._v(\"移除并返回集合中的一个随机元素。如果只想获取一个随机元素，但不想该元素从集合中被移除的话，可以使用 SRANDMEMBER 命令。\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"SREM\")])]),t._v(\" \"),e(\"td\",[t._v(\"SREM key member [member ...]\")]),t._v(\" \"),e(\"td\",[t._v(\"移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略。当 key 不是集合类型，返回一个错误\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"SSCAN\")]),t._v(\" \"),e(\"td\",[t._v(\"SSCAN key cursor [MATCH pattern] [COUNT count]\")]),t._v(\" \"),e(\"td\",[t._v(\"迭代集合中的元素\")]),t._v(\" \"),e(\"td\")])])]),t._v(\" \"),e(\"h4\",{attrs:{id:\"sortedset-有序集合-常用命令\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#sortedset-有序集合-常用命令\"}},[t._v(\"#\")]),t._v(\" SortedSet（有序集合）常用命令\")]),t._v(\" \"),e(\"table\",[e(\"thead\",[e(\"tr\",[e(\"th\",[t._v(\"命令\")]),t._v(\" \"),e(\"th\",[t._v(\"用法\")]),t._v(\" \"),e(\"th\",[t._v(\"描述\")]),t._v(\" \"),e(\"th\",[t._v(\"示例\")])])]),t._v(\" \"),e(\"tbody\",[e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"ZADD\")])]),t._v(\" \"),e(\"td\",[t._v(\"ZADD key score1 member1 [score2 member2]\")]),t._v(\" \"),e(\"td\",[t._v(\"向有序集合添加一个或多个成员，或者更新已存在成员的分数\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"ZCARD\")])]),t._v(\" \"),e(\"td\",[t._v(\"ZCARD key\")]),t._v(\" \"),e(\"td\",[t._v(\"返回有序集 key 的基数。\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"ZCOUNT\")])]),t._v(\" \"),e(\"td\",[t._v(\"ZCOUNT key min max\")]),t._v(\" \"),e(\"td\",[t._v(\"返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量。关于参数 min 和 max 的详细使用方法，请参考 ZRANGEBYSCORE 命令。\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"ZRANGE\")])]),t._v(\" \"),e(\"td\",[t._v(\"ZRANGE key start stop [WITHSCORES]\")]),t._v(\" \"),e(\"td\",[t._v(\"返回有序集 key 中，指定区间内的成员。其中成员的位置按 score 值递增(从小到大)来排序\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"ZREVRANGE\")])]),t._v(\" \"),e(\"td\",[t._v(\"ZREVRANGE key start stop [WITHSCORES]\")]),t._v(\" \"),e(\"td\",[t._v(\"返回有序集 key 中，指定区间内的成员。其中成员的位置按 score 值递减(从大到小)来排列。具有相同 score 值的成员按字典序的逆序(reverse lexicographical order)排列。除了成员按 score 值递减的次序排列这一点外， ZREVRANGE 命令的其他方面和 ZRANGE 命令一样。\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"ZREVRANGEBYSCORE\")]),t._v(\" \"),e(\"td\",[t._v(\"ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]\")]),t._v(\" \"),e(\"td\",[t._v(\"返回有序集 key 中， score 值介于 max 和 min 之间(默认包括等于 max 或 min )的所有的成员。有序集成员按 score 值递减(从大到小)的次序排列。\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"ZREVRANK\")]),t._v(\" \"),e(\"td\",[t._v(\"ZREVRANK key member\")]),t._v(\" \"),e(\"td\",[t._v(\"返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递减(从大到小)排序。排名以 0 为底，也就是说， score 值最大的成员排名为 0 。使用 ZRANK 命令可以获得成员按 score 值递增(从小到大)排列的排名。\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"ZSCORE\")]),t._v(\" \"),e(\"td\",[t._v(\"ZSCORE key member\")]),t._v(\" \"),e(\"td\",[t._v(\"返回有序集 key 中，成员 member 的 score 值。如果 member 元素不是有序集 key 的成员，或 key 不存在，返回 nil 。\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"ZRANGEBYSCORE\")]),t._v(\" \"),e(\"td\",[t._v(\"ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]\")]),t._v(\" \"),e(\"td\",[t._v(\"返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"ZRANK\")]),t._v(\" \"),e(\"td\",[t._v(\"ZRANK key member\")]),t._v(\" \"),e(\"td\",[t._v(\"返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列。\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[e(\"strong\",[t._v(\"ZINCRBY\")])]),t._v(\" \"),e(\"td\",[t._v(\"ZINCRBY key increment member\")]),t._v(\" \"),e(\"td\",[t._v(\"为有序集 key 的成员 member 的 score 值加上增量 increment\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"ZREM\")]),t._v(\" \"),e(\"td\",[t._v(\"ZREM key member [member ...]\")]),t._v(\" \"),e(\"td\",[t._v(\"移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。当 key 存在但不是有序集类型时，返回一个错误。\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"ZREMRANGEBYRANK\")]),t._v(\" \"),e(\"td\",[t._v(\"ZREMRANGEBYRANK key start stop\")]),t._v(\" \"),e(\"td\",[t._v(\"移除有序集 key 中，指定排名(rank)区间内的所有成员\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"ZREMRANGEBYSCORE\")]),t._v(\" \"),e(\"td\",[t._v(\"ZREMRANGEBYSCORE key min max\")]),t._v(\" \"),e(\"td\",[t._v(\"移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"ZUNIONSTORE\")]),t._v(\" \"),e(\"td\",[t._v(\"ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]\")]),t._v(\" \"),e(\"td\",[t._v(\"计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination 。默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之 和 。\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"ZINTERSTORE\")]),t._v(\" \"),e(\"td\",[t._v(\"ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]\")]),t._v(\" \"),e(\"td\",[t._v(\"计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 。默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之和.\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"ZSCAN\")]),t._v(\" \"),e(\"td\",[t._v(\"ZSCAN key cursor [MATCH pattern] [COUNT count]\")]),t._v(\" \"),e(\"td\",[t._v(\"迭代有序集合中的元素（包括元素成员和元素分值）\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"ZRANGEBYLEX\")]),t._v(\" \"),e(\"td\",[t._v(\"ZRANGEBYLEX key min max [LIMIT offset count]\")]),t._v(\" \"),e(\"td\",[t._v(\"当有序集合的所有成员都具有相同的分值时，有序集合的元素会根据成员的字典序（lexicographical ordering）来进行排序，而这个命令则可以返回给定的有序集合键 key 中，值介于 min 和 max 之间的成员。\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"ZLEXCOUNT\")]),t._v(\" \"),e(\"td\",[t._v(\"ZLEXCOUNT key min max\")]),t._v(\" \"),e(\"td\",[t._v(\"对于一个所有成员的分值都相同的有序集合键 key 来说，这个命令会返回该集合中，成员介于 min 和 max 范围内的元素数量。这个命令的 min 参数和 max 参数的意义和 ZRANGEBYLEX 命令的 min 参数和 max 参数的意义一样\")]),t._v(\" \"),e(\"td\")]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"ZREMRANGEBYLEX\")]),t._v(\" \"),e(\"td\",[t._v(\"ZREMRANGEBYLEX key min max\")]),t._v(\" \"),e(\"td\",[t._v(\"对于一个所有成员的分值都相同的有序集合键 key 来说，这个命令会移除该集合中，成员介于 min 和 max 范围内的所有元素。这个命令的 min 参数和 max 参数的意义和 ZRANGEBYLEX 命令的 min 参数和 max 参数的意义一样\")]),t._v(\" \"),e(\"td\")])])]),t._v(\" \"),e(\"h2\",{attrs:{id:\"其他数据类型\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#其他数据类型\"}},[t._v(\"#\")]),t._v(\" 其他数据类型\")]),t._v(\" \"),e(\"h3\",{attrs:{id:\"bitmaps\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#bitmaps\"}},[t._v(\"#\")]),t._v(\" bitmaps\")]),t._v(\" \"),e(\"h5\",{attrs:{id:\"☆☆位图\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#☆☆位图\"}},[t._v(\"#\")]),t._v(\" ☆☆位图：\")]),t._v(\" \"),e(\"p\",[t._v(\"String命令中包含了一种特殊的操作，直接操作bit，某些特殊场景下，会节省存储空间。可以在存取bool型数据的场景使用，比如存取用户男女比例，用户某一段日期签到记录，\")]),t._v(\" \"),e(\"p\",[t._v(\"​\\t在我们平时开发过程中，会有一些 bool 型数据需要存取，比如用户一年的签到记录，签了是 1，没签是 0，要记录 365 天。如果使用普通的 key/value，每个用户要记录 365 个，当用户上亿的时候，需要的存储空间是惊人的。\")]),t._v(\" \"),e(\"p\",[t._v(\"为了解决这个问题，Redis 提供了位图数据结构，这样每天的签到记录只占据一个位，365 天就是 365 个位，46 个字节 (一个稍长一点的字符串) 就可以完全容纳下，这就大大节约了存储空间。\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2018/7/2/1645926f4520d0ce?imageslim\",alt:\"img\"}})]),t._v(\" \"),e(\"p\",[t._v(\"位图不是特殊的数据结构，它的内容其实就是普通的字符串，也就是 byte 数组。我们可以使用普通的 get/set 直接获取和设置整个位图的内容，也可以使用位图操作 getbit/setbit 等将 byte 数组看成「位数组」来处理\")]),t._v(\" \"),e(\"p\",[t._v(\"Redis 的位数组是自动扩展，如果设置了某个偏移位置超出了现有的内容范围，就会自动将位数组进行零扩充。\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2018/7/2/16459860644097de?imageslim\",alt:\"img\"}})]),t._v(\" \"),e(\"p\",[t._v(\"接下来我们使用 redis-cli 设置第一个字符，也就是位数组的前 8 位，我们只需要设置值为 1 的位，如上图所示，h 字符只有 1/2/4 位需要设置，e 字符只有 9/10/13/15 位需要设置。值得注意的是位数组的顺序和字符的位顺序是相反的。\")]),t._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[t._v('127.0.0.1:6379> setbit s 1 1\\n(integer) 0\\n127.0.0.1:6379> setbit s 2 1\\n(integer) 0\\n127.0.0.1:6379> setbit s 4 1\\n(integer) 0\\n127.0.0.1:6379> setbit s 9 1\\n(integer) 0\\n127.0.0.1:6379> setbit s 10 1\\n(integer) 0\\n127.0.0.1:6379> setbit s 13 1\\n(integer) 0\\n127.0.0.1:6379> setbit s 15 1\\n(integer) 0\\n127.0.0.1:6379> get s\\n\"he\"\\n')])])]),e(\"p\",[t._v(\"上面这个例子可以理解为「零存整取」，同样我们还也可以「零存零取」，「整存零取」。「零存」就是使用 setbit 对位值进行逐个设置，「整存」就是使用字符串一次性填充所有位数组，覆盖掉旧值。\")]),t._v(\" \"),e(\"p\",[t._v(\"bitcount和bitop, bitpos,bitfield 都是操作位图的指令。\")]),t._v(\" \"),e(\"h3\",{attrs:{id:\"hyperloglog\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#hyperloglog\"}},[t._v(\"#\")]),t._v(\" HyperLogLog\")]),t._v(\" \"),e(\"p\",[t._v(\"Redis 在 2.8.9 版本添加了 HyperLogLog 结构。\")]),t._v(\" \"),e(\"p\",[t._v(\"场景：可以用来统计站点的UV...\")]),t._v(\" \"),e(\"p\",[t._v(\"Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。但是会有误差。\")]),t._v(\" \"),e(\"table\",[e(\"thead\",[e(\"tr\",[e(\"th\",[t._v(\"命令\")]),t._v(\" \"),e(\"th\",[t._v(\"用法\")]),t._v(\" \"),e(\"th\",[t._v(\"描述\")])])]),t._v(\" \"),e(\"tbody\",[e(\"tr\",[e(\"td\",[t._v(\"pfadd\")]),t._v(\" \"),e(\"td\",[t._v(\"[PFADD key element [element ...]\")]),t._v(\" \"),e(\"td\",[t._v(\"添加指定元素到 HyperLogLog 中\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"pfcount\")]),t._v(\" \"),e(\"td\",[t._v(\"[PFCOUNT key [key ...]\")]),t._v(\" \"),e(\"td\",[t._v(\"返回给定 HyperLogLog 的基数估算值。\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"pfmerge\")]),t._v(\" \"),e(\"td\",[t._v(\"[PFMERGE destkey sourcekey [sourcekey ...]\")]),t._v(\" \"),e(\"td\",[t._v(\"将多个 HyperLogLog 合并为一个 HyperLogLog\")])])])]),t._v(\" \"),e(\"div\",{staticClass:\"language-java extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-java\"}},[e(\"code\",[e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"public\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"class\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"JedisTest\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n  \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"public\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"static\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"main\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),e(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"String\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"[\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"]\")]),t._v(\" args\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    \"),e(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"Jedis\")]),t._v(\" jedis \"),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"new\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"Jedis\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n    \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"for\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"int\")]),t._v(\" i \"),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"0\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" i \"),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"<\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"100000\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" i\"),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"++\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n      jedis\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),e(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"pfadd\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),e(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"codehole\"')]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"user\"')]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"+\")]),t._v(\" i\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n    \"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\"\\n    \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"long\")]),t._v(\" total \"),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" jedis\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),e(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"pfcount\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),e(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"codehole\"')]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n    \"),e(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"System\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),t._v(\"out\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),e(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"printf\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),e(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"%d %d\\\\n\"')]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"100000\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" total\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n    jedis\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),e(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"close\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n  \"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\"\\n\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\"\\n\")])])]),e(\"p\",[e(\"a\",{attrs:{href:\"http://content.research.neustar.biz/blog/hll.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"HyperLogLog图解\"),e(\"OutboundLink\")],1)]),t._v(\" \"),e(\"h3\",{attrs:{id:\"geo\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#geo\"}},[t._v(\"#\")]),t._v(\" Geo\")])])}),[],!1,null,null,null);s.default=_.exports}}]);","extractedComments":[]}