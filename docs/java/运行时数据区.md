

# 运行时数据区

Java虚拟机定义了在运行期间使用的各种运行时数据区域

内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。

下图是jvm整体架构

![jvm-framework](/Users/starfish/Downloads/jvm (11).png)

tip>

你是否也有看不同的参考资料，有的内存结构图有方法区，有的又是永久代，元数据区，一脸懵逼的时候？

《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。永久代或元数据可以理解为方法区的落地实现。

方法区域在逻辑上是堆的一部分

**方法区（method area）**只是**JVM规范**中定义的一个概念，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，并没有规定如何去实现它，具体放在哪里，不同的实现可以放在不同的地方。而**永久代**是**Hotspot**虚拟机特有的概念，是方法区的一种实现。 

方法区是JVM规范的概念，而永久代则是Hotspot虚拟机特有的概念，是Java7对方法区的一种实现，永久代物理是是堆的一部分，和新生代，老年代地址是连续的。

Java8取消了永久代，采用了元空间，元空间属于本地内存，

存储内容不同，元空间存储类的元信息，静态变量和常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中



JVM8是个什么结构呢？

元数据区，以前叫永久代，或除了堆以外的区域，我们称为非堆空间

只有HotSpot JVM才有永久代

![](/Users/starfish/Desktop/截屏2020-02-09下午2.32.06.png)



Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程一一对应的数据区域会随着线程开始和结束而创建和销毁。

- 每个线程：独立包括程序计数器、栈、本地栈
- 线程间贡献：堆、堆外内存（永久代或元空间、代码缓存）



### Runtime

每个JVM只有一个Runtime实例，即为运行时环境，相当于内存结构的中间的那个框框：运行时环境

### 线程

线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。

在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。

操作系统负责所有线程的安排调度到任何一个可用的CPU上，一旦本地线程初始化成功，它就会调用Java线程中的run()方法。

- 如果你使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调动`public static void main(String[] args)`的main线程以及所有这个main线程自己创建的线程
- 这些主要的后台系统线程在Hotspot JVM里主要是以下几个：
  - **虚拟机线程**：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world“的垃圾收集，线程栈收集，线程挂起一起偏向所撤销
  - 周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行
  - GC线程：这种线程对JVM里不同种类的垃圾收集行为提供了支持
  - 编译线程：这种线程在运行时会将字节码编译成本地代码
  - 信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理



## 程序计数器（PC寄存器）

JVM器中的程序计数寄存（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息，CPU只有把数据装载到寄存器才能够运行。

这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。**JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟**。

#### 作用

PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。有执行引擎读取下一条指令。

![](/Users/starfish/Desktop/截屏2020-02-09下午5.40.00.png)

#### 概述

- 它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域
- 在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期一致
- 任何时间一个线程都只有一个方法在执行，也就是所谓的**当前方法**。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址，或者，如果是执行natice方法，则是未指定值（undefned）
- 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成
- 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
- 它是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域

![](/Users/starfish/Desktop/截屏2020-02-09下午6.22.14.png)

![](/Users/starfish/Desktop/截屏2020-02-09下午6.24.20.png)



## 虚拟机栈

#### 内存中的栈与堆

栈是运行时的单位，而堆是存储的单位。

栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。

![](/Users/starfish/Desktop/截屏2020-02-09下午8.05.50.png)

#### 栈中可能出现的异常

Java虚拟机规范允许Java栈的大小是动态的或者是固定不变的

- 如果采用固定大小的Java虚拟机栈，那每个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个**StackOverflowError**异常
- 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个**OutOfMemoryError**异常

#### 栈的存储单位

栈中存储什么？

- 每个线程都有自己的栈，栈中的数据都是以**栈帧（Stack Frame）的格式存在**
- 在这个线程上正在执行的每个方法都各自有对应的一个栈帧
- 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息

#### 栈运行原理

- JVM直接对Java栈的操作只有两个，对栈帧的**压栈**和**出栈**，遵循“先进后出/后进先出”原则

- 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为**当前栈帧**（Current Frame）,与当前栈帧对应的方法就是当前方法（Current Method）,定义这个方法的类就是**当前类**（Current Class）

- 执行引擎运行的所有字节码指令只针对当前栈帧进行操作

- 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前栈帧

  ![](/Users/starfish/Desktop/截屏2020-02-09下午8.24.50.png)

idea debug时候，可以在debug窗口看到Frames中各种方法的压栈和出栈

![](/Users/starfish/Desktop/截屏2020-02-09下午8.42.42.png)



- 不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧中引用另外一个线程的栈帧
- 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧
- Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出

#### 栈帧的内部结构

每个栈帧中存储着：

- 局部变量表（Local Variables）
- 操作数栈（Operand Stack）(或称为表达式栈)
- 动态链接（Dynamic Linking）(或指向运行时常量池的方法引用)
- 方法返回地址（Return Address）(或方法正常退出或异常退出的定义)
- 一些附加信息

![](/Users/starfish/Desktop/截屏2020-02-09下午9.04.30.png)



##### 局部变量表

- 局部变量表也被称为局部变量数组或者本地变量表
- 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（refrence）,以及returnAddress类型
- 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题
- **局部变量表所需要的容量大小是编译器确定下来的**，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的

![](/Users/starfish/Desktop/截屏2020-02-09下午9.48.55.png)

- ![](/Users/starfish/Desktop/截屏2020-02-09下午9.53.18.png)

可以通过插件jclasslib 查看各种信息

![](/Users/starfish/Desktop/截屏2020-02-09下午10.03.21.png)

![](/Users/starfish/Desktop/截屏2020-02-09下午10.04.50.png)

## 关于Slot的理解

- JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值
- 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个Slot上
- 如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量）
- 如果当前帧是由构造方法或实例方法创建的，那么该对象引用this将会存放在index为0的Slot处，其余的参数按照参数表顺序继续排列

![](/Users/starfish/Desktop/截屏2020-02-09下午10.07.23.png)

![](/Users/starfish/Desktop/截屏2020-02-09下午10.10.15.png)

静态方法不能用this

![](/Users/starfish/Desktop/截屏2020-02-09下午10.14.35.png)

![](/Users/starfish/Desktop/截屏2020-02-10上午10.33.11.png)

![](/Users/starfish/Desktop/截屏2020-02-10上午10.38.42.png)



##### 4.操作数栈

- 每个独立的栈帧中除了包含局部变量表之外，还包含一个**后进先出**（Last-In-First-Out）的操作数栈，也可以称为**表达式栈**（Expression Stack）

- **操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）、出栈（pop）**

  - 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈

  - 比如，执行复制、交换、求和等操作

    ![](/Users/starfish/Desktop/截屏2020-02-10上午10.51.01.png)

![](/Users/starfish/Desktop/截屏2020-02-10上午10.54.00.png)

## 操作数栈

- 操作数栈，**主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间**
- 操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的
- 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译器就定义好了，保存在方法的Code属性中，为max_stack的值
- 栈中的任何一个元素都是可以任意的Java数据类型
  - 32bit的类型占用一个栈单位深度
  - 64bit的类型占用两个栈单位深度
- 操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问
- **如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中**，并更新PC寄存器中下一条需要执行的字节码指令
- 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证
- 另外，我们说**Java虚拟机的解释引擎是基于栈的执行引擎**，其中的栈指的就是操作数栈

##### 5.代码追踪

![](/Users/starfish/Desktop/截屏2020-02-10上午11.06.21.png)

![](/Users/starfish/Desktop/截屏2020-02-10上午11.11.52.png)

##### 6. 栈顶缓存（Top-of-stack-Cashing）

前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数

由于操作数是存储在内存中的，因此频繁的执行内存读/写操作必然会影响执行速度。为例解决这个问题，HotSpot JVM设计者们提出了栈顶缓存技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率

##### 7.动态链接（或指向运行时常量池的方法引用）

- 每一个栈帧内部都包含一个指向**运行时常量池**中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接(Dynamic Linking)。
- 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Synbolic Reference）保存在class文件的常量池中。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么**动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用**

![](/Users/starfish/Desktop/截屏2020-02-10下午1.35.03.png)

![](/Users/starfish/Desktop/截屏2020-02-10下午1.47.08.png)

![](/Users/starfish/Desktop/截屏2020-02-10下午1.46.30.png)

##### 8.方法的调用

在JVM中，将符号引用转换为调用方法的直接引用于方法的绑定机制有关

- 静态链接：当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译器可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接
- 动态链接：如果被调用的方法在编译期无法被确定下来，也就是说，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接

![](/Users/starfish/Desktop/截屏2020-02-10下午1.54.26.png)

![](/Users/starfish/Desktop/截屏2020-02-10下午1.57.07.png)

![](/Users/starfish/Desktop/截屏2020-02-10下午2.05.35.png)

![](/Users/starfish/Desktop/截屏2020-02-10下午2.10.27.png)

![](/Users/starfish/Desktop/截屏2020-02-10下午2.11.49.png)

**invokedynamic指令的使用**

![](/Users/starfish/Desktop/截屏2020-02-10下午2.12.17.png)

![](/Users/starfish/Desktop/截屏2020-02-10下午2.21.24.png)

##### 9.方法返回地址（return address）

- 存放调用该方法的pc寄存器的值
- 一个方法的结束，有两种方式
  - 正常执行完成
  - 出现未处理的异常，非正常退出
- 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定的，栈帧中一般不会保存这部分信息



![](/Users/starfish/Desktop/截屏2020-02-10下午2.24.34.png)

![](/Users/starfish/Desktop/截屏2020-02-10下午2.26.17.png)

### 方法返回地址（return address）

本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去

正常完成出口和异常完成出口的区别在于：**通过异常完成出口退出的不会给他的上层调用者产生任何的返回值**



##### 10.附加信息

栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。



## faq

- 举例栈溢出的情况？
- 调整栈大小，就能保存不出现溢出吗？
- 分配的栈内存越大越好吗
- 垃圾回收是否会涉及到虚拟机栈
- 方法中定义的局部变量是否线程安全