{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{602:function(t,s,a){\"use strict\";a.r(s);var e=a(4),v=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"redis-数据类型篇\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#redis-数据类型篇\"}},[t._v(\"#\")]),t._v(\" Redis 数据类型篇\")]),t._v(\" \"),a(\"blockquote\",[a(\"p\",[t._v(\"一提到 Redis，我们的脑子里马上就会出现一个词：“快。”\")]),t._v(\" \"),a(\"p\",[t._v(\"数据库这么多，为啥 Redis 能有这么突出的表现呢？一方面，这是因为它是内存数据库，所有操作都在内存上完成，内存的访问速度本身就很快。另一方面，这要归功于它的数据结构。\")]),t._v(\" \"),a(\"p\",[t._v(\"这是因为，键值对是按一定的数据结构来组织的，操作键值对最终就是对数据结构进行增删改查操作，所以高效的数据结构是 Redis 快速处理数据的基础。\")])]),t._v(\" \"),a(\"h2\",{attrs:{id:\"一、redis-的五种基本数据类型和其数据结构\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#一、redis-的五种基本数据类型和其数据结构\"}},[t._v(\"#\")]),t._v(\" 一、Redis 的五种基本数据类型和其数据结构\")]),t._v(\" \"),a(\"p\",[t._v(\"由于 Redis 是基于标准 C 写的，只有最基础的数据类型，因此 Redis 为了满足对外使用的 5 种数据类型，开发了属于自己\"),a(\"strong\",[t._v(\"独有的一套基础数据结构\")]),t._v(\"，使用这些数据结构来实现 5 种数据类型。\")]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"Redis\")]),t._v(\" 有 5 种基础数据类型，它们分别是：\"),a(\"strong\",[t._v(\"string(字符串)\")]),t._v(\"、\"),a(\"strong\",[t._v(\"list(列表)\")]),t._v(\"、\"),a(\"strong\",[t._v(\"hash(字典)\")]),t._v(\"、\"),a(\"strong\",[t._v(\"set(集合)\")]),t._v(\" 和 \"),a(\"strong\",[t._v(\"zset(有序集合)\")]),t._v(\"。\")]),t._v(\" \"),a(\"p\",[t._v(\"Redis 底层的数据结构包括：\"),a(\"strong\",[t._v(\"简单动态数组SDS、链表、字典、跳跃链表、整数集合、压缩列表、对象。\")])]),t._v(\" \"),a(\"p\",[t._v(\"Redis 为了平衡空间和时间效率，针对 value 的具体类型在底层会采用不同的数据结构来实现，其中哈希表和压缩列表是复用比较多的数据结构，如下图展示了对外数据类型和底层数据结构之间的映射关系：\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://tva1.sinaimg.cn/large/007S8ZIlly1ge0k8do3s3j30im0el7aa.jpg\",alt:\"\"}})]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://static001.geekbang.org/resource/image/82/01/8219f7yy651e566d47cc9f661b399f01.jpg\",alt:\"img\"}})]),t._v(\" \"),a(\"blockquote\",[a(\"p\",[t._v(\"安装好 Redis，我们可以使用 \"),a(\"code\",[t._v(\"redis-cli\")]),t._v(\" 来对 Redis 进行命令行的操作，当然 Redis 官方也提供了在线的调试器，你也可以在里面敲入命令进行操作：http://try.redis.io/#run\")])]),t._v(\" \"),a(\"h3\",{attrs:{id:\"键和值用什么结构组织\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#键和值用什么结构组织\"}},[t._v(\"#\")]),t._v(\" 键和值用什么结构组织？\")]),t._v(\" \"),a(\"p\",[t._v(\"为了实现从键到值的快速访问，Redis 使用了一个哈希表来保存所有键值对。一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。类似我们的 HashMap\")]),t._v(\" \"),a(\"p\",[t._v(\"看到这里，你可能会问了：“如果值是集合类型的话，作为数组元素的哈希桶怎么来保存呢？”\")]),t._v(\" \"),a(\"p\",[t._v(\"其实，哈希桶中的元素保存的并不是值本身，而是指向具体值的指针。这也就是说，不管值是 String，还是集合类型，哈希桶中的元素都是指向它们的指针。\")]),t._v(\" \"),a(\"p\",[t._v(\"在下图中，可以看到，哈希桶中的 entry 元素中保存了 \"),a(\"code\",[t._v(\"*key\")]),t._v(\" 和  \"),a(\"code\",[t._v(\"*value\")]),t._v(\" 指针，分别指向了实际的键和值，这样一来，即使值是一个集合，也可以通过 \"),a(\"code\",[t._v(\"*value\")]),t._v(\" 指针被查找到。\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://static001.geekbang.org/resource/image/1c/5f/1cc8eaed5d1ca4e3cdbaa5a3d48dfb5f.jpg\",alt:\"img\"}})]),t._v(\" \"),a(\"p\",[t._v(\"因为这个哈希表保存了所有的键值对，所以，我也把它称为全局哈希表。哈希表的最大好处很明显，就是让我们可以用 \"),a(\"mjx-container\",{staticClass:\"MathJax\",attrs:{jax:\"SVG\"}},[a(\"svg\",{staticStyle:{\"vertical-align\":\"-0.566ex\"},attrs:{xmlns:\"http://www.w3.org/2000/svg\",width:\"4.618ex\",height:\"2.262ex\",viewBox:\"0 -750 2041 1000\"}},[a(\"g\",{attrs:{stroke:\"currentColor\",fill:\"currentColor\",\"stroke-width\":\"0\",transform:\"matrix(1 0 0 -1 0 0)\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"math\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"mi\"}},[a(\"path\",{attrs:{\"data-c\":\"4F\",d:\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(763, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"28\",d:\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mn\",transform:\"translate(1152, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"31\",d:\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(1652, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"29\",d:\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"}})])])])])]),t._v(\" 的时间复杂度来快速查找到键值对——我们只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素。\")],1),t._v(\" \"),a(\"p\",[t._v(\"你看，这个查找过程主要依赖于哈希计算，和数据量的多少并没有直接关系。也就是说，不管哈希表里有 10 万个键还是 100 万个键，我们只需要一次计算就能找到相应的键。但是，如果你只是了解了哈希表的 \"),a(\"mjx-container\",{staticClass:\"MathJax\",attrs:{jax:\"SVG\"}},[a(\"svg\",{staticStyle:{\"vertical-align\":\"-0.566ex\"},attrs:{xmlns:\"http://www.w3.org/2000/svg\",width:\"4.618ex\",height:\"2.262ex\",viewBox:\"0 -750 2041 1000\"}},[a(\"g\",{attrs:{stroke:\"currentColor\",fill:\"currentColor\",\"stroke-width\":\"0\",transform:\"matrix(1 0 0 -1 0 0)\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"math\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"mi\"}},[a(\"path\",{attrs:{\"data-c\":\"4F\",d:\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(763, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"28\",d:\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mn\",transform:\"translate(1152, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"31\",d:\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(1652, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"29\",d:\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"}})])])])])]),t._v(\" 复杂度和快速查找特性，那么，当你往 Redis 中写入大量数据后，就可能发现操作有时候会突然变慢了。这其实是因为你忽略了一个潜在的风险点，那就是哈希表的冲突问题和 rehash 可能带来的操作阻塞。\")],1),t._v(\" \"),a(\"h3\",{attrs:{id:\"为什么哈希表操作变慢了\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#为什么哈希表操作变慢了\"}},[t._v(\"#\")]),t._v(\" 为什么哈希表操作变慢了？\")]),t._v(\" \"),a(\"p\",[t._v(\"当你往哈希表中写入更多数据时，哈希冲突是不可避免的问题。这里的哈希冲突，也就是指，两个 key 的哈希值和哈希桶计算对应关系时，正好落在了同一个哈希桶中。毕竟，哈希桶的个数通常要少于 key 的数量，这也就是说，难免会有一些 key 的哈希值对应到了同一个哈希桶中。\")]),t._v(\" \"),a(\"p\",[t._v(\"Redis 解决哈希冲突的方式，就是链式哈希。和 JDK7 中的 HahsMap 类似，链式哈希也很容易理解，\"),a(\"strong\",[t._v(\"就是指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接\")]),t._v(\"。\")]),t._v(\" \"),a(\"p\",[t._v(\"如下图所示：entry1、entry2 和 entry3 都需要保存在哈希桶 3 中，导致了哈希冲突。此时，entry1 元素会通过一个 \"),a(\"code\",[t._v(\"*next\")]),t._v(\" 指针指向 entry2，同样，entry2 也会通过 \"),a(\"code\",[t._v(\"*next\")]),t._v(\" 指针指向 entry3。这样一来，即使哈希桶 3 中的元素有 100 个，我们也可以通过 entry 元素中的指针，把它们连起来。这就形成了一个链表，也叫作哈希冲突链。\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://static001.geekbang.org/resource/image/8a/28/8ac4cc6cf94968a502161f85d072e428.jpg\",alt:\"img\"}})]),t._v(\" \"),a(\"p\",[t._v(\"但是，这里依然存在一个问题，哈希冲突链上的元素只能通过指针逐一查找再操作。如果哈希表里写入的数据越来越多，哈希冲突可能也会越来越多，这就会导致某些哈希冲突链过长，进而导致这个链上的元素查找耗时长，效率降低。对于追求“快”的 Redis 来说，这是不太能接受的。\")]),t._v(\" \"),a(\"p\",[t._v(\"所以，Redis 会对哈希表做 rehash 操作。rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。那具体怎么做呢？\")]),t._v(\" \"),a(\"p\",[t._v(\"其实，为了使 rehash 操作更高效，Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：\")]),t._v(\" \"),a(\"ol\",[a(\"li\",[t._v(\"给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；\")]),t._v(\" \"),a(\"li\",[t._v(\"把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；\")]),t._v(\" \"),a(\"li\",[t._v(\"释放哈希表 1 的空间。\")])]),t._v(\" \"),a(\"p\",[t._v(\"到此，我们就可以从哈希表 1 切换到哈希表 2，用增大的哈希表 2 保存更多数据，而原来的哈希表 1 留作下一次 rehash 扩容备用。这个过程看似简单，但是第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。此时，Redis 就无法快速访问数据了。为了避免这个问题，Redis 采用了渐进式 rehash。\")]),t._v(\" \"),a(\"p\",[t._v(\"简单来说就是在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。如下图所示：\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://static001.geekbang.org/resource/image/73/0c/73fb212d0b0928d96a0d7d6ayy76da0c.jpg\",alt:\"img\"}})]),t._v(\" \"),a(\"p\",[t._v(\"渐进式 rehash 这样就巧妙地把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作，保证了数据的快速访问。\")]),t._v(\" \"),a(\"p\",[t._v(\"好了，到这里，你应该就能理解，Redis 的键和值是怎么通过哈希表组织的了。对于 String 类型来说，找到哈希桶就能直接增删改查了，所以，哈希表的 \"),a(\"mjx-container\",{staticClass:\"MathJax\",attrs:{jax:\"SVG\"}},[a(\"svg\",{staticStyle:{\"vertical-align\":\"-0.566ex\"},attrs:{xmlns:\"http://www.w3.org/2000/svg\",width:\"4.618ex\",height:\"2.262ex\",viewBox:\"0 -750 2041 1000\"}},[a(\"g\",{attrs:{stroke:\"currentColor\",fill:\"currentColor\",\"stroke-width\":\"0\",transform:\"matrix(1 0 0 -1 0 0)\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"math\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"mi\"}},[a(\"path\",{attrs:{\"data-c\":\"4F\",d:\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(763, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"28\",d:\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mn\",transform:\"translate(1152, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"31\",d:\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(1652, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"29\",d:\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"}})])])])])]),t._v(\" 操作复杂度也就是它的复杂度了。但是，对于集合类型来说，即使找到哈希桶了，还要在集合中再进一步操作。\")],1),t._v(\" \"),a(\"p\",[t._v(\"下面我们具体看下各种数据类型的底层实现和操作。\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"_1、string-字符串\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1、string-字符串\"}},[t._v(\"#\")]),t._v(\" 1、String（字符串）\")]),t._v(\" \"),a(\"p\",[t._v(\"String 是 Redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。\")]),t._v(\" \"),a(\"p\",[t._v(\"String 类型是二进制安全的。意思是 Redis 的 String 可以包含任何数据。比如 jpg 图片或者序列化的对象 。\")]),t._v(\" \"),a(\"p\",[t._v(\"Redis 的字符串是动态字符串，是可以修改的字符串，\"),a(\"strong\",[t._v(\"内部结构实现上类似于 Java 的 ArrayList\")]),t._v(\"，采用预分配冗余空间的方式来减少内存的频繁分配，如图中所示，内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度 len。当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是字符串最大长度为 512M。\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"http://ww1.sinaimg.cn/large/9b9f09a9ly1g9ypoobef5j20fw04pq2p.jpg\",alt:\"redis-string.jpg\"}})]),t._v(\" \"),a(\"p\",[t._v(\"Redis 没有直接使用 C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称 C 字符串）， 而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型， 并将 SDS 用作 Redis 的默认字符串表示。\")]),t._v(\" \"),a(\"p\",[t._v(\"根据传统， C 语言使用长度为 \"),a(\"code\",[t._v(\"N+1\")]),t._v(\" 的字符数组来表示长度为 \"),a(\"code\",[t._v(\"N\")]),t._v(\" 的字符串， 并且字符数组的最后一个元素总是空字符 \"),a(\"code\",[t._v(\"'\\\\0'\")]),t._v(\" 。\")]),t._v(\" \"),a(\"p\",[t._v(\"比如说， 图 2-3 就展示了一个值为 \"),a(\"code\",[t._v('\"Redis\"')]),t._v(\" 的 C 字符串：\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"http://redisbook.com/_images/graphviz-cd9ca0391fd6ab95a2c5b48d5f5fbd0da2db1cab.png\",alt:\"\"}})]),t._v(\" \"),a(\"p\",[t._v(\"C 语言使用的这种简单的字符串表示方式， 并不能满足 Redis 对字符串在安全性、效率、以及功能方面的要求\")]),t._v(\" \"),a(\"p\",[a(\"a\",{attrs:{href:\"http://redisbook.com/preview/sds/different_between_sds_and_c_string.html\",title:\"SDS 与 C 字符串的区别\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"下面说明 SDS 比 C 字符串更适用于 Redis 的原因\"),a(\"OutboundLink\")],1),t._v(\"：\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[a(\"p\",[a(\"strong\",[t._v(\"常数复杂度获取字符串长度\")])]),t._v(\" \"),a(\"p\",[t._v(\"因为 C 字符串并不记录自身的长度信息， 所以为了获取一个 C 字符串的长度， 程序必须遍历整个字符串，对遇到的每个字符进行计数， 直到遇到代表字符串结尾的空字符为止， 这个操作的复杂度为 \"),a(\"mjx-container\",{staticClass:\"MathJax\",attrs:{jax:\"SVG\"}},[a(\"svg\",{staticStyle:{\"vertical-align\":\"-0.566ex\"},attrs:{xmlns:\"http://www.w3.org/2000/svg\",width:\"5.495ex\",height:\"2.262ex\",viewBox:\"0 -750 2429 1000\"}},[a(\"g\",{attrs:{stroke:\"currentColor\",fill:\"currentColor\",\"stroke-width\":\"0\",transform:\"matrix(1 0 0 -1 0 0)\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"math\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"mi\"}},[a(\"path\",{attrs:{\"data-c\":\"4F\",d:\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(763, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"28\",d:\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mi\",transform:\"translate(1152, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"4E\",d:\"M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(2040, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"29\",d:\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"}})])])])])])],1),t._v(\" \"),a(\"p\",[t._v(\"和 C 字符串不同， 因为 SDS 在 \"),a(\"code\",[t._v(\"len\")]),t._v(\" 属性中记录了 SDS 本身的长度， 所以获取一个 SDS 长度的复杂度仅为 \"),a(\"mjx-container\",{staticClass:\"MathJax\",attrs:{jax:\"SVG\"}},[a(\"svg\",{staticStyle:{\"vertical-align\":\"-0.566ex\"},attrs:{xmlns:\"http://www.w3.org/2000/svg\",width:\"4.618ex\",height:\"2.262ex\",viewBox:\"0 -750 2041 1000\"}},[a(\"g\",{attrs:{stroke:\"currentColor\",fill:\"currentColor\",\"stroke-width\":\"0\",transform:\"matrix(1 0 0 -1 0 0)\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"math\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"mi\"}},[a(\"path\",{attrs:{\"data-c\":\"4F\",d:\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(763, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"28\",d:\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mn\",transform:\"translate(1152, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"31\",d:\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(1652, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"29\",d:\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"}})])])])])])],1),t._v(\" \"),a(\"p\",[t._v(\"举个例子， 对于图 2-5 所示的 SDS 来说， 程序只要访问 SDS 的 \"),a(\"code\",[t._v(\"len\")]),t._v(\" 属性， 就可以立即知道 SDS 的长度为 \"),a(\"code\",[t._v(\"5\")]),t._v(\" 字节：\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"http://redisbook.com/_images/graphviz-dbd2f4d49a9f495f18093129393569f93e645529.png\",alt:\"\"}})]),t._v(\" \"),a(\"p\",[t._v(\"通过使用 SDS 而不是 C 字符串， Redis 将获取字符串长度所需的复杂度从 \"),a(\"mjx-container\",{staticClass:\"MathJax\",attrs:{jax:\"SVG\"}},[a(\"svg\",{staticStyle:{\"vertical-align\":\"-0.566ex\"},attrs:{xmlns:\"http://www.w3.org/2000/svg\",width:\"5.495ex\",height:\"2.262ex\",viewBox:\"0 -750 2429 1000\"}},[a(\"g\",{attrs:{stroke:\"currentColor\",fill:\"currentColor\",\"stroke-width\":\"0\",transform:\"matrix(1 0 0 -1 0 0)\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"math\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"mi\"}},[a(\"path\",{attrs:{\"data-c\":\"4F\",d:\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(763, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"28\",d:\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mi\",transform:\"translate(1152, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"4E\",d:\"M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(2040, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"29\",d:\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"}})])])])])]),t._v(\" 降低到了 \"),a(\"mjx-container\",{staticClass:\"MathJax\",attrs:{jax:\"SVG\"}},[a(\"svg\",{staticStyle:{\"vertical-align\":\"-0.566ex\"},attrs:{xmlns:\"http://www.w3.org/2000/svg\",width:\"4.618ex\",height:\"2.262ex\",viewBox:\"0 -750 2041 1000\"}},[a(\"g\",{attrs:{stroke:\"currentColor\",fill:\"currentColor\",\"stroke-width\":\"0\",transform:\"matrix(1 0 0 -1 0 0)\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"math\"}},[a(\"g\",{attrs:{\"data-mml-node\":\"mi\"}},[a(\"path\",{attrs:{\"data-c\":\"4F\",d:\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(763, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"28\",d:\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mn\",transform:\"translate(1152, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"31\",d:\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"}})]),a(\"g\",{attrs:{\"data-mml-node\":\"mo\",transform:\"translate(1652, 0)\"}},[a(\"path\",{attrs:{\"data-c\":\"29\",d:\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"}})])])])])]),t._v(\" ， 这确保了获取字符串长度的工作不会成为 Redis 的性能瓶颈\")],1)]),t._v(\" \"),a(\"li\",[a(\"p\",[a(\"strong\",[t._v(\"缓冲区溢出/内存泄漏\")])]),t._v(\" \"),a(\"p\",[t._v(\"跟上述问题原因一样，如果执行拼接 or 缩短字符串的操作，如果操作不当就很容易造成上述问题；\")])]),t._v(\" \"),a(\"li\",[a(\"p\",[a(\"strong\",[t._v(\"减少修改字符串带来的内存分配次数\")])]),t._v(\" \"),a(\"p\",[t._v(\"因为 C 字符串并不记录自身的长度， 所以对于一个包含了 \"),a(\"code\",[t._v(\"N\")]),t._v(\" 个字符的 C 字符串来说， 这个 C 字符串的底层实现总是一个 \"),a(\"code\",[t._v(\"N+1\")]),t._v(\" 个字符长的数组（额外的一个字符空间用于保存空字符）。\")]),t._v(\" \"),a(\"p\",[t._v(\"因为 C 字符串的长度和底层数组的长度之间存在着这种关联性， 所以每次增长或者缩短一个 C 字符串， 程序都总要对保存这个 C 字符串的数组进行一次内存重分配操作：\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"如果程序执行的是增长字符串的操作， 比如拼接操作（append）， 那么在执行这个操作之前， 程序需要先通过内存重分配来扩展底层数组的空间大小 —— 如果忘了这一步就会产生缓冲区溢出。\")]),t._v(\" \"),a(\"li\",[t._v(\"如果程序执行的是缩短字符串的操作， 比如截断操作（trim）， 那么在执行这个操作之后， 程序需要通过内存重分配来释放字符串不再使用的那部分空间 —— 如果忘了这一步就会产生内存泄漏。\")])]),t._v(\" \"),a(\"p\",[t._v(\"为了避免 C 字符串的这种缺陷， SDS 通过未使用空间解除了字符串长度和底层数组长度之间的关联： 在 SDS 中， \"),a(\"code\",[t._v(\"buf\")]),t._v(\" 数组的长度不一定就是字符数量加一， 数组里面可以包含未使用的字节， 而这些字节的数量就由 SDS 的 \"),a(\"code\",[t._v(\"free\")]),t._v(\" 属性记录。\")]),t._v(\" \"),a(\"p\",[t._v(\"通过未使用空间， SDS 实现了空间预分配和惰性空间释放两种优化策略。\")])]),t._v(\" \"),a(\"li\",[a(\"p\",[a(\"strong\",[t._v(\"二进制安全\")])]),t._v(\" \"),a(\"p\",[t._v(\"因为 C 语言中的字符串必须符合某种编码（比如 ASCII），并且除了字符串的末尾之外， 字符串里面不能包含空字符， 否则最先被程序读入的空字符将被误认为是字符串结尾 —— 这些限制使得 C 字符串只能保存文本数据， 而不能保存像图片、音频、视频、压缩文件这样的二进制数据\")])])]),t._v(\" \"),a(\"h3\",{attrs:{id:\"_2、list-列表\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2、list-列表\"}},[t._v(\"#\")]),t._v(\" 2、List（列表）\")]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"Redis 的列表相当于 Java 语言里面的 LinkedList，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)\")])]),t._v(\" \"),a(\"p\",[t._v(\"当列表弹出了最后一个元素之后，该数据结构自动被删除，内存被回收。\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://cdn.jsdelivr.net/gh/Jstarfish/picBed/img/20201116153913.gif\",alt:\"\"}})]),t._v(\" \"),a(\"p\",[t._v(\"Redis 的列表结构常用来做异步队列使用。将需要延后处理的任务结构体序列化成字符串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理\")]),t._v(\" \"),a(\"p\",[a(\"strong\",[t._v(\"右边进左边出：队列\")])]),t._v(\" \"),a(\"div\",{staticClass:\"language-shell extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-shell\"}},[a(\"code\",[a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" rpush books python java golang \\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"integer\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"3\")]),t._v(\" \\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"\\\\\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" llen books\\n \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"integer\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"3\")]),t._v(\" \\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"\\\\\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" lpop books\\n \"),a(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"python\"')]),t._v(\" \\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"\\\\\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" lpop books\\n \"),a(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"java\"')]),t._v(\" \\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"\\\\\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" lpop books \\n\"),a(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"golang\"')]),t._v(\" \\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"\\\\\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" lpop books \\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"nil\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n\")])])]),a(\"p\",[a(\"strong\",[t._v(\"右边进右边出：栈\")])]),t._v(\" \"),a(\"div\",{staticClass:\"language-shell extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-shell\"}},[a(\"code\",[a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" rpush books python java golang\\n \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"integer\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"3\")]),t._v(\"\\n \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"\\\\\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" rpop books \\n\"),a(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"golang\"')]),t._v(\" \\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"\\\\\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" rpop books \\n\"),a(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"java\"')]),t._v(\" \\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"\\\\\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" rpop books \\n\"),a(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"python\"')]),t._v(\"\\n \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"\\\\\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" rpop books\\n \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"nil\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n\")])])]),a(\"h4\",{attrs:{id:\"列表的实现\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#列表的实现\"}},[t._v(\"#\")]),t._v(\" \"),a(\"a\",{attrs:{href:\"http://redisbook.com/preview/adlist/implementation.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"列表的实现\"),a(\"OutboundLink\")],1)]),t._v(\" \"),a(\"p\",[t._v(\"我们可以从 \"),a(\"a\",{attrs:{href:\"https://github.com/redis/redis/blob/unstable/src/adlist.h\",title:\"redis源码\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"源码\"),a(\"OutboundLink\")],1),t._v(\" 的 \"),a(\"code\",[t._v(\"adlist.h/listNode\")]),t._v(\" 来看到对其的定义：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language-c extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-c\"}},[a(\"code\",[a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"/* Node, List, and Iterator are the only data structures used currently. */\")]),t._v(\"\\n\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"typedef\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"listNode\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"listNode\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"prev\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 前置节点\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"listNode\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"next\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 后置节点\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"value\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"           \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 节点的值\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\" listNode\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"typedef\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"listIter\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    listNode \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"next\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"int\")]),t._v(\" direction\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\" listIter\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"typedef\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"list\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    listNode \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"head\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\\t\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 表头节点\")]),t._v(\"\\n    listNode \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"tail\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\\t\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 表尾节点\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"dup\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"ptr\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 节点值复制函数\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"free\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"ptr\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 节点值释放函数\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"int\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"match\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"ptr\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"key\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 节点值对比函数\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"unsigned\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"long\")]),t._v(\" len\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 链表所包含的节点数量\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\" list\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\")])])]),a(\"p\",[t._v(\"对于 Javaer 我认为知道底层是个\"),a(\"strong\",[t._v(\"双端链表\")]),t._v(\"就够了，如果再深入一点，你会发现 Redis 底层存储的还不是一个简单的 \"),a(\"code\",[t._v(\"linkedlist\")]),t._v(\"，而是称之为快速链表 \"),a(\"code\",[t._v(\"quicklist\")]),t._v(\" 的一个结构。\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"_3、hash-字典\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3、hash-字典\"}},[t._v(\"#\")]),t._v(\" 3、Hash（字典）\")]),t._v(\" \"),a(\"p\",[t._v(\"Redis hash 是一个键值对集合。KV 模式不变，但 V 是一个键值对。\")]),t._v(\" \"),a(\"p\",[t._v(\"Redis 的字典相当于 Java 语言里面的 HashMap，它是无序字典， 内部实现结构上同 Java 的 HashMap 也是一致的，同样的\"),a(\"strong\",[t._v(\"数组 + 链表\")]),t._v(\"二维结构。第一维 hash 的数组位置碰撞时，就会将碰撞的元素使用链表串接起来。\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"http://ww1.sinaimg.cn/large/9b9f09a9ly1g9ypp2rs05j20g307pa9u.jpg\",alt:\"redis-hash.jpg\"}})]),t._v(\" \"),a(\"p\",[t._v(\"不同的是，Redis 的字典的值只能是字符串，另外它们 rehash 的方式不一样，因为 Java 的 HashMap 在字典很大时，rehash 是个耗时的操作，需要一次性全部 rehash。Redis 为了高性能，不能堵塞服务，所以采用了渐进式 rehash 策略。\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://cdn.jsdelivr.net/gh/Jstarfish/picBed/img/20201116154218.png\",alt:\"redis-rehash\"}})]),t._v(\" \"),a(\"p\",[t._v(\"渐进式 rehash 会在 rehash 的同时，保留新旧两个 hash 结构，查询时会同时查询两个 hash 结构，然后在后续的定时任务中以及 hash 操作指令中，循序渐进地将旧 hash 的内容一点点迁移到新的 hash 结构中。当搬迁完成了，就会使用新的 hash 结构取而代之。\")]),t._v(\" \"),a(\"p\",[t._v(\"当 hash 移除了最后一个元素之后，该数据结构自动被删除，内存被回收。\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://cdn.jsdelivr.net/gh/Jstarfish/picBed/img/20201116154311.gif\",alt:\"\"}})]),t._v(\" \"),a(\"p\",[t._v(\"hash 结构也可以用来存储用户信息，不同于字符串一次性需要全部序列化整个对象，hash 可以对用户结构中的每个字段单独存储。这样当我们需要获取用户信息时可以进行部分获取。而以整个字符串的形式去保存用户信息的话就只能一次性全部读取，这样就会比较浪费网络流量。\")]),t._v(\" \"),a(\"p\",[t._v(\"hash 也有缺点，hash 结构的存储消耗要高于单个字符串，到底该使用 hash 还是字符串，需要根据实际情况再三权衡。\")]),t._v(\" \"),a(\"h4\",{attrs:{id:\"字典的实现\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#字典的实现\"}},[t._v(\"#\")]),t._v(\" \"),a(\"a\",{attrs:{href:\"http://redisbook.com/preview/dict/datastruct.html\",title:\"字典的实现\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"字典的实现\"),a(\"OutboundLink\")],1)]),t._v(\" \"),a(\"p\",[t._v(\"Redis 字典源码由 \"),a(\"code\",[t._v(\"dict.h/dictht\")]),t._v(\" 结构定义：\")]),t._v(\" \"),a(\"div\",{staticClass:\"language-c extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-c\"}},[a(\"code\",[a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"typedef\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"dictEntry\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"key\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"union\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n        \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"val\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n        uint64_t u64\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n        int64_t s64\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n        \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"double\")]),t._v(\" d\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\" v\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"dictEntry\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"next\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\" dictEntry\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"/* This is our hash table structure. Every dictionary has two of this as we\\n * implement incremental rehashing, for the old to the new table. */\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"typedef\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"dictht\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    dictEntry \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"table\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" \\t\\t\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 哈希表数组\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"unsigned\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"long\")]),t._v(\" size\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\\t\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 哈希表大小\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"unsigned\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"long\")]),t._v(\" sizemask\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 哈希表大小掩码，用于计算索引值,总是等于 size - 1\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"unsigned\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"long\")]),t._v(\" used\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\\t\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 该哈希表已有节点的数量\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\" dictht\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"typedef\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"dict\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    dictType \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"type\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 类型特定函数\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"*\")]),t._v(\"privdata\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 私有数据 \")]),t._v(\"\\n    dictht ht\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"[\")]),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"2\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"]\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\t\"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// 哈希表\")]),t._v(\"\\n\\t\"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"long\")]),t._v(\" rehashidx\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"/* rehashing not in progress if rehashidx == -1 */\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"unsigned\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"long\")]),t._v(\" iterators\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"/* number of iterators currently running */\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\" dict\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\")])])]),a(\"h3\",{attrs:{id:\"_4、set-集合\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4、set-集合\"}},[t._v(\"#\")]),t._v(\" 4、Set（集合）\")]),t._v(\" \"),a(\"p\",[t._v(\"Redis 的 Set 是 String 类型的无序集合。它是通过 HashTable 实现的， 相当于 Java 语言里面的 HashSet，它内部的键值对是无序的唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值\"),a(\"code\",[t._v(\"NULL\")]),t._v(\"。\")]),t._v(\" \"),a(\"p\",[t._v(\"当集合中最后一个元素移除之后，数据结构自动删除，内存被回收。\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://cdn.jsdelivr.net/gh/Jstarfish/picBed/img/20201116154820.gif\",alt:\"img\"}})]),t._v(\" \"),a(\"h3\",{attrs:{id:\"_5、zset-sorted-set-有序集合\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5、zset-sorted-set-有序集合\"}},[t._v(\"#\")]),t._v(\" 5、zset(sorted set：有序集合)\")]),t._v(\" \"),a(\"p\",[t._v(\"zset 和 set 一样也是 String 类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。\")]),t._v(\" \"),a(\"p\",[t._v(\"Redis 正是通过分数来为集合中的成员进行从小到大的排序。zset 的成员是唯一的，但分数(score)却可以重复。\")]),t._v(\" \"),a(\"p\",[t._v(\"它类似于 Java 的 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的排序权重。它的内部实现用的是一种叫做「\"),a(\"strong\",[t._v(\"跳跃列表\")]),t._v(\"」的数据结构。\")]),t._v(\" \"),a(\"p\",[t._v(\"zset 中最后一个 value 被移除后，数据结构自动删除，内存被回收。\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://cdn.jsdelivr.net/gh/Jstarfish/picBed/img/20201116154851.gif\",alt:\"img\"}})]),t._v(\" \"),a(\"h2\",{attrs:{id:\"二、其他数据类型\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#二、其他数据类型\"}},[t._v(\"#\")]),t._v(\" 二、其他数据类型\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"bitmaps\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#bitmaps\"}},[t._v(\"#\")]),t._v(\" bitmaps\")]),t._v(\" \"),a(\"h5\",{attrs:{id:\"☆☆位图\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#☆☆位图\"}},[t._v(\"#\")]),t._v(\" ☆☆位图：\")]),t._v(\" \"),a(\"p\",[t._v(\"在我们平时开发过程中，会有一些 bool 型数据需要存取，比如用户一年的签到记录，签了是 1，没签是 0，要记录 365 天。如果使用普通的 key/value，每个用户要记录 365 个，当用户上亿的时候，需要的存储空间是惊人的。\")]),t._v(\" \"),a(\"p\",[t._v(\"为了解决这个问题，Redis 提供了位图数据结构，这样每天的签到记录只占据一个位，365 天就是 365 个位，46 个字节 (一个稍长一点的字符串) 就可以完全容纳下，这就大大节约了存储空间。\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://cdn.jsdelivr.net/gh/Jstarfish/picBed/img/20201116155417.gif\",alt:\"img\"}})]),t._v(\" \"),a(\"p\",[t._v(\"位图不是特殊的数据结构，它的内容其实就是普通的字符串，也就是 byte 数组。我们可以使用普通的 get/set 直接获取和设置整个位图的内容，也可以使用位图操作 getbit/setbit 等将 byte 数组看成「位数组」来处理\")]),t._v(\" \"),a(\"p\",[t._v(\"Redis 的位数组是自动扩展，如果设置了某个偏移位置超出了现有的内容范围，就会自动将位数组进行零扩充。\")]),t._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://cdn.jsdelivr.net/gh/Jstarfish/picBed/img/20201116155452.gif\",alt:\"\"}})]),t._v(\" \"),a(\"p\",[t._v(\"接下来我们使用 redis-cli 设置第一个字符，也就是位数组的前 8 位，我们只需要设置值为 1 的位，如上图所示，h 字符只有 1/2/4 位需要设置，e 字符只有 9/10/13/15 位需要设置。值得注意的是位数组的顺序和字符的位顺序是相反的。\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v('127.0.0.1:6379> setbit s 1 1\\n(integer) 0\\n127.0.0.1:6379> setbit s 2 1\\n(integer) 0\\n127.0.0.1:6379> setbit s 4 1\\n(integer) 0\\n127.0.0.1:6379> setbit s 9 1\\n(integer) 0\\n127.0.0.1:6379> setbit s 10 1\\n(integer) 0\\n127.0.0.1:6379> setbit s 13 1\\n(integer) 0\\n127.0.0.1:6379> setbit s 15 1\\n(integer) 0\\n127.0.0.1:6379> get s\\n\"he\"\\n')])])]),a(\"p\",[t._v(\"上面这个例子可以理解为「零存整取」，同样我们还也可以「零存零取」，「整存零取」。「零存」就是使用 setbit 对位值进行逐个设置，「整存」就是使用字符串一次性填充所有位数组，覆盖掉旧值。\")]),t._v(\" \"),a(\"p\",[t._v(\"bitcount 和 bitop,  bitpos, bitfield 都是操作位图的指令。\")]),t._v(\" \"),a(\"h3\",{attrs:{id:\"hyperloglog\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#hyperloglog\"}},[t._v(\"#\")]),t._v(\" HyperLogLog\")]),t._v(\" \"),a(\"p\",[t._v(\"Redis 在 2.8.9 版本添加了 HyperLogLog 结构。\")]),t._v(\" \"),a(\"p\",[t._v(\"场景：可以用来统计站点的UV...\")]),t._v(\" \"),a(\"p\",[t._v(\"Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。但是会有误差。\")]),t._v(\" \"),a(\"table\",[a(\"thead\",[a(\"tr\",[a(\"th\",[t._v(\"命令\")]),t._v(\" \"),a(\"th\",[t._v(\"用法\")]),t._v(\" \"),a(\"th\",[t._v(\"描述\")])])]),t._v(\" \"),a(\"tbody\",[a(\"tr\",[a(\"td\",[t._v(\"pfadd\")]),t._v(\" \"),a(\"td\",[t._v(\"[PFADD key element [element ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"添加指定元素到 HyperLogLog 中\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"pfcount\")]),t._v(\" \"),a(\"td\",[t._v(\"[PFCOUNT key [key ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"返回给定 HyperLogLog 的基数估算值。\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"pfmerge\")]),t._v(\" \"),a(\"td\",[t._v(\"[PFMERGE destkey sourcekey [sourcekey ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"将多个 HyperLogLog 合并为一个 HyperLogLog\")])])])]),t._v(\" \"),a(\"div\",{staticClass:\"language-java extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-java\"}},[a(\"code\",[a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"public\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"class\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"JedisTest\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n  \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"public\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"static\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"main\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"String\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"[\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"]\")]),t._v(\" args\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"Jedis\")]),t._v(\" jedis \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"new\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"Jedis\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"for\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"int\")]),t._v(\" i \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"0\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" i \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"<\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"100000\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" i\"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"++\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n      jedis\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),a(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"pfadd\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"codehole\"')]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"user\"')]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"+\")]),t._v(\" i\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"long\")]),t._v(\" total \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" jedis\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),a(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"pfcount\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"codehole\"')]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"System\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),t._v(\"out\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),a(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"printf\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token string\"}},[t._v('\"%d %d\\\\n\"')]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"100000\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" total\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n    jedis\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),a(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"close\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n  \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\"\\n\")])])]),a(\"p\",[a(\"a\",{attrs:{href:\"http://content.research.neustar.biz/blog/hll.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"HyperLogLog图解\"),a(\"OutboundLink\")],1)]),t._v(\" \"),a(\"h3\",{attrs:{id:\"geo\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#geo\"}},[t._v(\"#\")]),t._v(\" Geo\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"三、redis常见数据类型和命令查阅\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#三、redis常见数据类型和命令查阅\"}},[t._v(\"#\")]),t._v(\" 三、Redis常见数据类型和命令查阅：\")]),t._v(\" \"),a(\"p\",[a(\"a\",{attrs:{href:\"http://www.redis.cn/commands.html\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"Redis命令中心\"),a(\"OutboundLink\")],1)]),t._v(\" \"),a(\"h4\",{attrs:{id:\"key-键-常用命令\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#key-键-常用命令\"}},[t._v(\"#\")]),t._v(\" Key（键）常用命令\")]),t._v(\" \"),a(\"table\",[a(\"thead\",[a(\"tr\",[a(\"th\",[t._v(\"命令\")]),t._v(\" \"),a(\"th\",[t._v(\"用法\")]),t._v(\" \"),a(\"th\",[t._v(\"描述\")]),t._v(\" \"),a(\"th\",[t._v(\"示例\")])])]),t._v(\" \"),a(\"tbody\",[a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"DEL\")])]),t._v(\" \"),a(\"td\",[t._v(\"DEL key [key ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"删除给定的一个或多个 key。 不存在的 key 会被忽略\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"DUMP\")]),t._v(\" \"),a(\"td\",[t._v(\"DUMP key\")]),t._v(\" \"),a(\"td\",[t._v(\"序列化给定 key ，并返回被序列化的值，使用 RESTORE 命令可以将这个值反序列化为 Redis 键\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"EXISTS\")]),t._v(\" \"),a(\"td\",[t._v(\"EXISTS key\")]),t._v(\" \"),a(\"td\",[t._v(\"检查给定 key 是否存在\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"EXPIRE\")])]),t._v(\" \"),a(\"td\",[t._v(\"EXPIRE key seconds\")]),t._v(\" \"),a(\"td\",[t._v(\"为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"PERSIST\")])]),t._v(\" \"),a(\"td\",[t._v(\"PERSIST key\")]),t._v(\" \"),a(\"td\",[t._v(\"移除 key 的过期时间，key 将持久保持。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"EXPIREAT\")])]),t._v(\" \"),a(\"td\",[t._v(\"EXPIREAT key timestamp\")]),t._v(\" \"),a(\"td\",[t._v(\"EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置生存时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)\")]),t._v(\" \"),a(\"td\",[t._v(\"EXPIREAT cache 1355292000     # 这个 key 将在 2012.12.12 过期\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"KEYS\")])]),t._v(\" \"),a(\"td\",[t._v(\"KEYS pattern\")]),t._v(\" \"),a(\"td\",[t._v(\"查找所有符合给定模式 pattern 的 key\")]),t._v(\" \"),a(\"td\",[t._v(\"KEYS *  # 匹配数据库内所有 key\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"MOVE\")]),t._v(\" \"),a(\"td\",[t._v(\"MOVE key db\")]),t._v(\" \"),a(\"td\",[t._v(\"将当前数据库的 key 移动到给定的数据库 db 当中如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 key ，或者 key 不存在于当前数据库，那么 MOVE 没有任何效果。 因此，也可以利用这一特性，将 MOVE 当作锁(locking)原语(primitive)\")]),t._v(\" \"),a(\"td\",[t._v(\"MOVE song 1                          # 将 song 移动到数据库 1\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"TTL\")])]),t._v(\" \"),a(\"td\",[t._v(\"TTL key\")]),t._v(\" \"),a(\"td\",[t._v(\"以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)当 key 不存在时，返回 -2 。当 key 存在但没有设置剩余生存时间时，返回 -1 。否则，以秒为单位，返回 key 的剩余生存时间\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"PTTL\")]),t._v(\" \"),a(\"td\",[t._v(\"PTTL key\")]),t._v(\" \"),a(\"td\",[t._v(\"以毫秒为单位返回 key 的剩余的过期时间。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"TYPE\")])]),t._v(\" \"),a(\"td\",[t._v(\"TYPE key\")]),t._v(\" \"),a(\"td\",[t._v(\"返回 key 所储存的值的类型\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"RENAME\")]),t._v(\" \"),a(\"td\",[t._v(\"RENAME key newkey\")]),t._v(\" \"),a(\"td\",[t._v(\"将 key 改名为 newkey 。当 key 和 newkey 相同，或者 key 不存在时，返回一个错误。当 newkey 已经存在时， RENAME 命令将覆盖旧值\")]),t._v(\" \"),a(\"td\")])])]),t._v(\" \"),a(\"h4\",{attrs:{id:\"string-字符串-常用命令\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#string-字符串-常用命令\"}},[t._v(\"#\")]),t._v(\" String （字符串）常用命令\")]),t._v(\" \"),a(\"table\",[a(\"thead\",[a(\"tr\",[a(\"th\",[t._v(\"命令\")]),t._v(\" \"),a(\"th\",[t._v(\"用法\")]),t._v(\" \"),a(\"th\",[t._v(\"描述\")]),t._v(\" \"),a(\"th\",[t._v(\"示例\")])])]),t._v(\" \"),a(\"tbody\",[a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"SET\")])]),t._v(\" \"),a(\"td\",[t._v(\"SET key value [EX seconds] [PX milliseconds] [NX|XX]\")]),t._v(\" \"),a(\"td\",[t._v(\"将字符串值 value 关联到 key 。如果 key 已经持有其他值， SET 就覆写旧值，无视类型\")]),t._v(\" \"),a(\"td\",[t._v('SET key \"value\"')])]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"MSET\")])]),t._v(\" \"),a(\"td\",[t._v(\"MSET key value [key value ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"同时设置一个或多个 key-value 对。如果某个给定 key 已经存在，那么 MSET 会用新值覆盖原来的旧值，如果这不是你所希望的效果，请考虑使用 MSETNX 命令：它只会在所有给定 key 都不存在的情况下进行设置操作\")]),t._v(\" \"),a(\"td\",[t._v('MSET date \"2012.3.30\" time \"11:00 a.m.\" weather \"sunny\"')])]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"SETNX\")])]),t._v(\" \"),a(\"td\",[t._v(\"SETNX key value\")]),t._v(\" \"),a(\"td\",[t._v(\"将 key 的值设为 value ，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作 SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"MSETNX\")]),t._v(\" \"),a(\"td\",[t._v(\"MSETNX key value [key value ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。即使只有一个给定 key 已存在， MSETNX 也会拒绝执行所有给定 key 的设置操作\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"SETRANGE\")]),t._v(\" \"),a(\"td\",[t._v(\"SETRANGE key offset value\")]),t._v(\" \"),a(\"td\",[t._v(\"用 value 参数覆写(overwrite)给定 key 所储存的字符串值，从偏移量 offset 开始。不存在的 key 当作空白字符串处理\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"SETBIT\")]),t._v(\" \"),a(\"td\",[t._v(\"SETBIT key offset value\")]),t._v(\" \"),a(\"td\",[t._v(\"对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)\")]),t._v(\" \"),a(\"td\",[t._v(\"GETBIT bit 100   # bit 默认被初始化为 0\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"SETEX\")]),t._v(\" \"),a(\"td\",[t._v(\"SETEX key seconds value\")]),t._v(\" \"),a(\"td\",[t._v(\"将值 value 关联到 key ，并将 key 的生存时间设为 seconds (以秒为单位)。如果 key 已经存在， SETEX 命令将覆写旧值。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"PSETEX\")]),t._v(\" \"),a(\"td\",[t._v(\"PSETEX key milliseconds value\")]),t._v(\" \"),a(\"td\",[t._v(\"这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"STRLEN\")]),t._v(\" \"),a(\"td\",[t._v(\"STRLEN key\")]),t._v(\" \"),a(\"td\",[t._v(\"返回 key 所储存的字符串值的长度。当 key 储存的不是字符串值时，返回一个错误\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"GET\")])]),t._v(\" \"),a(\"td\",[t._v(\"GET key\")]),t._v(\" \"),a(\"td\",[t._v(\"返回 key 所关联的字符串值。如果 key 不存在那么返回特殊值 nil\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"MGET\")])]),t._v(\" \"),a(\"td\",[t._v(\"MGET key [key ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"返回所有(一个或多个)给定 key 的值。如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil 。因此，该命令永不失败\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"GETRANGE\")]),t._v(\" \"),a(\"td\",[t._v(\"GETRANGE key start end\")]),t._v(\" \"),a(\"td\",[t._v(\"返回 key 中字符串值的子字符串，字符串的截取范围由 start 和 end 两个偏移量决定(包括 start 和 end 在内)。负数偏移量表示从字符串最后开始计数， -1 表示最后一个字符， -2 表示倒数第二个，以此类推。\")]),t._v(\" \"),a(\"td\",[t._v(\"GETRANGE greeting 0 4\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"GETSET\")]),t._v(\" \"),a(\"td\",[t._v(\"GETSET key value\")]),t._v(\" \"),a(\"td\",[t._v(\"将给定 key 的值设为 value ，并返回 key 的旧值(old value)。当 key 存在但不是字符串类型时，返回一个错误。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"GETBIT\")]),t._v(\" \"),a(\"td\",[t._v(\"GETBIT key offset\")]),t._v(\" \"),a(\"td\",[t._v(\"对 key 所储存的字符串值，获取指定偏移量上的位(bit)。当 offset 比字符串值的长度大，或者 key 不存在时，返回 0\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"APPEND\")])]),t._v(\" \"),a(\"td\",[t._v(\"APPEND key value\")]),t._v(\" \"),a(\"td\",[t._v(\"如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。如果 key 不存在， APPEND 就简单地将给定 key 设为 value ，就像执行 SET key value 一样\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"DECR\")])]),t._v(\" \"),a(\"td\",[t._v(\"DECR key\")]),t._v(\" \"),a(\"td\",[t._v(\"将 key 中储存的数字值减一。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECR 操作\")]),t._v(\" \"),a(\"td\",[t._v(\"redis> SET failure_times 10OK redis> DECR failure_times(integer) 9\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"DECRBY\")])]),t._v(\" \"),a(\"td\",[t._v(\"DECRBY key decrement\")]),t._v(\" \"),a(\"td\",[t._v(\"将 key 所储存的值减去减量 decrement\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"INCR\")])]),t._v(\" \"),a(\"td\",[t._v(\"INCR key\")]),t._v(\" \"),a(\"td\",[t._v(\"将 key 中储存的数字值增一。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"INCRBY\")])]),t._v(\" \"),a(\"td\",[t._v(\"INCRBY key increment\")]),t._v(\" \"),a(\"td\",[t._v(\"将 key 所储存的值加上增量 increment\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"INCRBYFLOAT\")]),t._v(\" \"),a(\"td\",[t._v(\"INCRBYFLOAT key increment\")]),t._v(\" \"),a(\"td\",[t._v(\"为 key 中所储存的值加上浮点数增量 increment\")]),t._v(\" \"),a(\"td\",[t._v(\"INCRBYFLOAT mykey 0.1\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"BITCOUNT\")]),t._v(\" \"),a(\"td\",[t._v(\"BITCOUNT key [start] [end]\")]),t._v(\" \"),a(\"td\",[t._v(\"计算给定字符串中，被设置为 1 的比特位的数量\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"BITOP\")]),t._v(\" \"),a(\"td\",[t._v(\"BITOP operation destkey key [key ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。\")]),t._v(\" \"),a(\"td\")])])]),t._v(\" \"),a(\"h4\",{attrs:{id:\"list-列表-常用命令\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#list-列表-常用命令\"}},[t._v(\"#\")]),t._v(\" List（列表）常用命令\")]),t._v(\" \"),a(\"table\",[a(\"thead\",[a(\"tr\",[a(\"th\",[t._v(\"命令\")]),t._v(\" \"),a(\"th\",[t._v(\"用法\")]),t._v(\" \"),a(\"th\",[t._v(\"描述\")]),t._v(\" \"),a(\"th\",[t._v(\"示例\")])])]),t._v(\" \"),a(\"tbody\",[a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"LPUSH\")])]),t._v(\" \"),a(\"td\",[t._v(\"LPUSH key value [value ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"将一个或多个值 value 插入到列表 key 的表头如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表头\")]),t._v(\" \"),a(\"td\",[t._v(\"正着进反着出\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"LPUSHX\")]),t._v(\" \"),a(\"td\",[t._v(\"LPUSHX key value\")]),t._v(\" \"),a(\"td\",[t._v(\"将值 value 插入到列表 key 的表头，当且仅当 key 存在并且是一个列表。和 LPUSH 命令相反，当 key 不存在时， LPUSHX 命令什么也不做\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"RPUSH\")])]),t._v(\" \"),a(\"td\",[t._v(\"RPUSH key value [value ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"将一个或多个值 value 插入到列表 key 的表尾(最右边)\")]),t._v(\" \"),a(\"td\",[t._v(\"怎么进怎么出\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"RPUSHX\")]),t._v(\" \"),a(\"td\",[t._v(\"RPUSHX key value\")]),t._v(\" \"),a(\"td\",[t._v(\"将值 value 插入到列表 key 的表尾，当且仅当 key 存在并且是一个列表。和 RPUSH 命令相反，当 key 不存在时， RPUSHX 命令什么也不做。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"LPOP\")])]),t._v(\" \"),a(\"td\",[t._v(\"LPOP key\")]),t._v(\" \"),a(\"td\",[t._v(\"移除并返回列表 key 的头元素。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"BLPOP\")])]),t._v(\" \"),a(\"td\",[t._v(\"BLPOP key [key ...] timeout\")]),t._v(\" \"),a(\"td\",[t._v(\"移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"RPOP\")])]),t._v(\" \"),a(\"td\",[t._v(\"RPOP key\")]),t._v(\" \"),a(\"td\",[t._v(\"移除并返回列表 key 的尾元素。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"BRPOP\")])]),t._v(\" \"),a(\"td\",[t._v(\"BRPOP key [key ...] timeout\")]),t._v(\" \"),a(\"td\",[t._v(\"移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"BRPOPLPUSH\")]),t._v(\" \"),a(\"td\",[t._v(\"BRPOPLPUSH source destination timeout\")]),t._v(\" \"),a(\"td\",[t._v(\"从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"RPOPLPUSH\")]),t._v(\" \"),a(\"td\",[t._v(\"RPOPLPUSH source destinationb\")]),t._v(\" \"),a(\"td\",[t._v(\"命令 RPOPLPUSH 在一个原子时间内，执行以下两个动作：将列表 source 中的最后一个元素(尾元素)弹出，并返回给客户端。将 source 弹出的元素插入到列表 destination ，作为 destination 列表的的头元素\")]),t._v(\" \"),a(\"td\",[t._v(\"RPOPLPUSH list01 list02\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"LSET\")])]),t._v(\" \"),a(\"td\",[t._v(\"LSET key index value\")]),t._v(\" \"),a(\"td\",[t._v(\"将列表 key 下标为 index 的元素的值设置为 value\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"LLEN\")])]),t._v(\" \"),a(\"td\",[t._v(\"LLEN key\")]),t._v(\" \"),a(\"td\",[t._v(\"返回列表 key 的长度。如果 key 不存在，则 key 被解释为一个空列表，返回 0 .如果 key 不是列表类型，返回一个错误\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"LINDEX\")])]),t._v(\" \"),a(\"td\",[t._v(\"LINDEX key index\")]),t._v(\" \"),a(\"td\",[t._v(\"返回列表 key 中，下标为 index 的元素。下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。相当于 Java 链表的\"),a(\"code\",[t._v(\"get(int index)\")]),t._v(\"方法，它需要对链表进行遍历，性能随着参数\"),a(\"code\",[t._v(\"index\")]),t._v(\"增大而变差。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"LRANGE\")])]),t._v(\" \"),a(\"td\",[t._v(\"LRANGE key start stop\")]),t._v(\" \"),a(\"td\",[t._v(\"返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"LREM\")]),t._v(\" \"),a(\"td\",[t._v(\"LREM key count value\")]),t._v(\" \"),a(\"td\",[t._v(\"根据参数 count 的值，移除列表中与参数 value 相等的元素\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"LTRIM\")]),t._v(\" \"),a(\"td\",[t._v(\"LTRIM key start stop\")]),t._v(\" \"),a(\"td\",[t._v(\"对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"LINSERT\")]),t._v(\" \"),a(\"td\",[t._v(\"LINSERT key BEFORE|AFTER pivot value\")]),t._v(\" \"),a(\"td\",[t._v(\"将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。当 pivot 不存在于列表 key 时，不执行任何操作。当 key 不存在时， key 被视为空列表，不执行任何操作。如果 key 不是列表类型，返回一个错误。\")]),t._v(\" \"),a(\"td\",[t._v(\"LINSERT list01 before c++ c#(在c++之前加上C#)\")])])])]),t._v(\" \"),a(\"h4\",{attrs:{id:\"hash-哈希表-常用命令\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#hash-哈希表-常用命令\"}},[t._v(\"#\")]),t._v(\" \"),a(\"strong\",[t._v(\"Hash\")]),t._v(\"（哈希表）常用命令\")]),t._v(\" \"),a(\"table\",[a(\"thead\",[a(\"tr\",[a(\"th\",[t._v(\"命令\")]),t._v(\" \"),a(\"th\",[t._v(\"用法\")]),t._v(\" \"),a(\"th\",[t._v(\"描述\")]),t._v(\" \"),a(\"th\",[t._v(\"示例\")])])]),t._v(\" \"),a(\"tbody\",[a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"HSET\")])]),t._v(\" \"),a(\"td\",[t._v(\"HSET key field value\")]),t._v(\" \"),a(\"td\",[t._v(\"将哈希表 key 中的域 field 的值设为 value 。如果 key 不存在，一个新的哈希表被创建并进行 HSET 操作。如果域 field 已经存在于哈希表中，旧值将被覆盖。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"HMSET\")])]),t._v(\" \"),a(\"td\",[t._v(\"HMSET key field value [field value ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"同时将多个 field-value (域-值)对设置到哈希表 key 中。此命令会覆盖哈希表中已存在的域。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"HSETNX\")])]),t._v(\" \"),a(\"td\",[t._v(\"HSETNX key field value\")]),t._v(\" \"),a(\"td\",[t._v(\"将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在。若域 field 已经存在，该操作无效\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"HGET\")])]),t._v(\" \"),a(\"td\",[t._v(\"HGET key field\")]),t._v(\" \"),a(\"td\",[t._v(\"返回哈希表 key 中给定域 field 的值\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"HMGET\")])]),t._v(\" \"),a(\"td\",[t._v(\"HMGET key field [field ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"返回哈希表 key 中，一个或多个给定域的值。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"HGETALL\")])]),t._v(\" \"),a(\"td\",[t._v(\"HGETALL key\")]),t._v(\" \"),a(\"td\",[t._v(\"返回哈希表 key 中，所有的域和值。在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"HDEL\")]),t._v(\" \"),a(\"td\",[t._v(\"HDEL key field [field ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"HEXISTS\")]),t._v(\" \"),a(\"td\",[t._v(\"HEXISTS key field\")]),t._v(\" \"),a(\"td\",[t._v(\"查看哈希表 key 中，给定域 field 是否存在\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"HLEN\")]),t._v(\" \"),a(\"td\",[t._v(\"HLEN key\")]),t._v(\" \"),a(\"td\",[t._v(\"返回哈希表 key 中域的数量\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"HKEYS\")])]),t._v(\" \"),a(\"td\",[t._v(\"HKEYS key\")]),t._v(\" \"),a(\"td\",[t._v(\"返回哈希表 key 中的所有域\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"HVALS\")])]),t._v(\" \"),a(\"td\",[t._v(\"HVALS key\")]),t._v(\" \"),a(\"td\",[t._v(\"返回哈希表 key 中所有域的值\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"HSTRLEN\")]),t._v(\" \"),a(\"td\",[t._v(\"HSTRLEN key field\")]),t._v(\" \"),a(\"td\",[t._v(\"返回哈希表 key 中，与给定域 field 相关联的值的字符串长度（string length）。如果给定的键或者域不存在，那么命令返回 0\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"HINCRBY\")]),t._v(\" \"),a(\"td\",[t._v(\"HINCRBY key field increment\")]),t._v(\" \"),a(\"td\",[t._v(\"为哈希表 key 中的域 field 的值加上增量 increment\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"HINCRBYFLOAT\")]),t._v(\" \"),a(\"td\",[t._v(\"HINCRBYFLOAT key field increment\")]),t._v(\" \"),a(\"td\",[t._v(\"为哈希表 key 中的域 field 加上浮点数增量 increment\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"HSCAN\")]),t._v(\" \"),a(\"td\",[t._v(\"HSCAN key cursor [MATCH pattern] [COUNT count]\")]),t._v(\" \"),a(\"td\",[t._v(\"迭代哈希表中的键值对。\")]),t._v(\" \"),a(\"td\")])])]),t._v(\" \"),a(\"h4\",{attrs:{id:\"set-集合-常用命令\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#set-集合-常用命令\"}},[t._v(\"#\")]),t._v(\" Set（集合）常用命令\")]),t._v(\" \"),a(\"table\",[a(\"thead\",[a(\"tr\",[a(\"th\",[t._v(\"命令\")]),t._v(\" \"),a(\"th\",[t._v(\"用法\")]),t._v(\" \"),a(\"th\",[t._v(\"描述\")]),t._v(\" \"),a(\"th\",[t._v(\"示例\")])])]),t._v(\" \"),a(\"tbody\",[a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"SADD\")])]),t._v(\" \"),a(\"td\",[t._v(\"SADD key member [member ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。假如 key 不存在，则创建一个只包含 member 元素作成员的集合。当 key 不是集合类型时，返回一个错误\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"SCARD\")])]),t._v(\" \"),a(\"td\",[t._v(\"SCARD key\")]),t._v(\" \"),a(\"td\",[t._v(\"返回集合 key 的基数(集合中元素的数量)。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"SDIFF\")])]),t._v(\" \"),a(\"td\",[t._v(\"SDIFF key [key ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"返回一个集合的全部成员，该集合是所有给定集合之间的差集。不存在的 key 被视为空集。\")]),t._v(\" \"),a(\"td\",[t._v(\"差集\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"SDIFFSTORE\")]),t._v(\" \"),a(\"td\",[t._v(\"SDIFFSTORE destination key [key ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"这个命令的作用和 SDIFF 类似，但它将结果保存到 destination 集合，而不是简单地返回结果集。如果 destination 集合已经存在，则将其覆盖。destination 可以是 key 本身。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"SINTER\")])]),t._v(\" \"),a(\"td\",[t._v(\"SINTER key [key ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"返回一个集合的全部成员，该集合是所有给定集合的交集。不存在的 key 被视为空集。当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)\")]),t._v(\" \"),a(\"td\",[t._v(\"交集\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"SINTERSTORE\")]),t._v(\" \"),a(\"td\",[t._v(\"SINTERSTORE destination key [key ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"这个命令类似于 SINTER 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。如果 destination 集合已经存在，则将其覆盖。destination 可以是 key 本身\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"SUNION\")])]),t._v(\" \"),a(\"td\",[t._v(\"SUNION key [key ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"返回一个集合的全部成员，该集合是所有给定集合的并集。不存在的 key 被视为空集\")]),t._v(\" \"),a(\"td\",[t._v(\"并集\")])]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"SUNIONSTORE\")]),t._v(\" \"),a(\"td\",[t._v(\"SUNIONSTORE destination key [key ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"这个命令类似于 SUNION 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。如果 destination 已经存在，则将其覆盖。destination 可以是 key 本身\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"SMEMBERS\")])]),t._v(\" \"),a(\"td\",[t._v(\"SMEMBERS key\")]),t._v(\" \"),a(\"td\",[t._v(\"返回集合 key 中的所有成员。不存在的 key 被视为空集合\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"SRANDMEMBER\")]),t._v(\" \"),a(\"td\",[t._v(\"SRANDMEMBER key [count]\")]),t._v(\" \"),a(\"td\",[t._v(\"如果命令执行时，只提供了 key 参数，那么返回集合中的一个随机元素\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"SISMEMBER\")])]),t._v(\" \"),a(\"td\",[t._v(\"SISMEMBER key member\")]),t._v(\" \"),a(\"td\",[t._v(\"判断 member 元素是否集合 key 的成员\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"SMOVE\")]),t._v(\" \"),a(\"td\",[t._v(\"SMOVE source destination member\")]),t._v(\" \"),a(\"td\",[t._v(\"将 member 元素从 source 集合移动到 destination 集合。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"SPOP\")]),t._v(\" \"),a(\"td\",[t._v(\"SPOP key\")]),t._v(\" \"),a(\"td\",[t._v(\"移除并返回集合中的一个随机元素。如果只想获取一个随机元素，但不想该元素从集合中被移除的话，可以使用 SRANDMEMBER 命令。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"SREM\")])]),t._v(\" \"),a(\"td\",[t._v(\"SREM key member [member ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略。当 key 不是集合类型，返回一个错误\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"SSCAN\")]),t._v(\" \"),a(\"td\",[t._v(\"SSCAN key cursor [MATCH pattern] [COUNT count]\")]),t._v(\" \"),a(\"td\",[t._v(\"迭代集合中的元素\")]),t._v(\" \"),a(\"td\")])])]),t._v(\" \"),a(\"h4\",{attrs:{id:\"sortedset-有序集合-常用命令\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#sortedset-有序集合-常用命令\"}},[t._v(\"#\")]),t._v(\" SortedSet（有序集合）常用命令\")]),t._v(\" \"),a(\"table\",[a(\"thead\",[a(\"tr\",[a(\"th\",[t._v(\"命令\")]),t._v(\" \"),a(\"th\",[t._v(\"用法\")]),t._v(\" \"),a(\"th\",[t._v(\"描述\")]),t._v(\" \"),a(\"th\",[t._v(\"示例\")])])]),t._v(\" \"),a(\"tbody\",[a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"ZADD\")])]),t._v(\" \"),a(\"td\",[t._v(\"ZADD key score1 member1 [score2 member2]\")]),t._v(\" \"),a(\"td\",[t._v(\"向有序集合添加一个或多个成员，或者更新已存在成员的分数\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"ZCARD\")])]),t._v(\" \"),a(\"td\",[t._v(\"ZCARD key\")]),t._v(\" \"),a(\"td\",[t._v(\"返回有序集 key 的基数。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"ZCOUNT\")])]),t._v(\" \"),a(\"td\",[t._v(\"ZCOUNT key min max\")]),t._v(\" \"),a(\"td\",[t._v(\"返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量。关于参数 min 和 max 的详细使用方法，请参考 ZRANGEBYSCORE 命令。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"ZRANGE\")])]),t._v(\" \"),a(\"td\",[t._v(\"ZRANGE key start stop [WITHSCORES]\")]),t._v(\" \"),a(\"td\",[t._v(\"返回有序集 key 中，指定区间内的成员。其中成员的位置按 score 值递增(从小到大)来排序\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"ZREVRANGE\")])]),t._v(\" \"),a(\"td\",[t._v(\"ZREVRANGE key start stop [WITHSCORES]\")]),t._v(\" \"),a(\"td\",[t._v(\"返回有序集 key 中，指定区间内的成员。其中成员的位置按 score 值递减(从大到小)来排列。具有相同 score 值的成员按字典序的逆序(reverse lexicographical order)排列。除了成员按 score 值递减的次序排列这一点外， ZREVRANGE 命令的其他方面和 ZRANGE 命令一样。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"ZREVRANGEBYSCORE\")]),t._v(\" \"),a(\"td\",[t._v(\"ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]\")]),t._v(\" \"),a(\"td\",[t._v(\"返回有序集 key 中， score 值介于 max 和 min 之间(默认包括等于 max 或 min )的所有的成员。有序集成员按 score 值递减(从大到小)的次序排列。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"ZREVRANK\")]),t._v(\" \"),a(\"td\",[t._v(\"ZREVRANK key member\")]),t._v(\" \"),a(\"td\",[t._v(\"返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递减(从大到小)排序。排名以 0 为底，也就是说， score 值最大的成员排名为 0 。使用 ZRANK 命令可以获得成员按 score 值递增(从小到大)排列的排名。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"ZSCORE\")]),t._v(\" \"),a(\"td\",[t._v(\"ZSCORE key member\")]),t._v(\" \"),a(\"td\",[t._v(\"返回有序集 key 中，成员 member 的 score 值。如果 member 元素不是有序集 key 的成员，或 key 不存在，返回 nil 。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"ZRANGEBYSCORE\")]),t._v(\" \"),a(\"td\",[t._v(\"ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]\")]),t._v(\" \"),a(\"td\",[t._v(\"返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"ZRANK\")]),t._v(\" \"),a(\"td\",[t._v(\"ZRANK key member\")]),t._v(\" \"),a(\"td\",[t._v(\"返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[a(\"strong\",[t._v(\"ZINCRBY\")])]),t._v(\" \"),a(\"td\",[t._v(\"ZINCRBY key increment member\")]),t._v(\" \"),a(\"td\",[t._v(\"为有序集 key 的成员 member 的 score 值加上增量 increment\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"ZREM\")]),t._v(\" \"),a(\"td\",[t._v(\"ZREM key member [member ...]\")]),t._v(\" \"),a(\"td\",[t._v(\"移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。当 key 存在但不是有序集类型时，返回一个错误。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"ZREMRANGEBYRANK\")]),t._v(\" \"),a(\"td\",[t._v(\"ZREMRANGEBYRANK key start stop\")]),t._v(\" \"),a(\"td\",[t._v(\"移除有序集 key 中，指定排名(rank)区间内的所有成员\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"ZREMRANGEBYSCORE\")]),t._v(\" \"),a(\"td\",[t._v(\"ZREMRANGEBYSCORE key min max\")]),t._v(\" \"),a(\"td\",[t._v(\"移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"ZUNIONSTORE\")]),t._v(\" \"),a(\"td\",[t._v(\"ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]\")]),t._v(\" \"),a(\"td\",[t._v(\"计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination 。默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之 和 。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"ZINTERSTORE\")]),t._v(\" \"),a(\"td\",[t._v(\"ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]\")]),t._v(\" \"),a(\"td\",[t._v(\"计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 。默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之和.\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"ZSCAN\")]),t._v(\" \"),a(\"td\",[t._v(\"ZSCAN key cursor [MATCH pattern] [COUNT count]\")]),t._v(\" \"),a(\"td\",[t._v(\"迭代有序集合中的元素（包括元素成员和元素分值）\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"ZRANGEBYLEX\")]),t._v(\" \"),a(\"td\",[t._v(\"ZRANGEBYLEX key min max [LIMIT offset count]\")]),t._v(\" \"),a(\"td\",[t._v(\"当有序集合的所有成员都具有相同的分值时，有序集合的元素会根据成员的字典序（lexicographical ordering）来进行排序，而这个命令则可以返回给定的有序集合键 key 中，值介于 min 和 max 之间的成员。\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"ZLEXCOUNT\")]),t._v(\" \"),a(\"td\",[t._v(\"ZLEXCOUNT key min max\")]),t._v(\" \"),a(\"td\",[t._v(\"对于一个所有成员的分值都相同的有序集合键 key 来说，这个命令会返回该集合中，成员介于 min 和 max 范围内的元素数量。这个命令的 min 参数和 max 参数的意义和 ZRANGEBYLEX 命令的 min 参数和 max 参数的意义一样\")]),t._v(\" \"),a(\"td\")]),t._v(\" \"),a(\"tr\",[a(\"td\",[t._v(\"ZREMRANGEBYLEX\")]),t._v(\" \"),a(\"td\",[t._v(\"ZREMRANGEBYLEX key min max\")]),t._v(\" \"),a(\"td\",[t._v(\"对于一个所有成员的分值都相同的有序集合键 key 来说，这个命令会移除该集合中，成员介于 min 和 max 范围内的所有元素。这个命令的 min 参数和 max 参数的意义和 ZRANGEBYLEX 命令的 min 参数和 max 参数的意义一样\")]),t._v(\" \"),a(\"td\")])])])])}),[],!1,null,null,null);s.default=v.exports}}]);","extractedComments":[]}