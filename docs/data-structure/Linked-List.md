## 链表

链表是一系列的存储数据元素的单元通过指针串接起来形成的，因此每个单元至少有两个域，一个域用于数据元素的存储，另一个域是指向其他单元的指针。这里具有一个数据域和多个指针域的存储单元通常称为**结点**（node）。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gh5uzihd52j30io078wer.jpg)

一种最简单的结点结构如上图所示，它是构成单链表的基本结点结构。在结点中数据域用来存储数据元素，指针域用于指向下一个具有相同结构的结点。

在 Java 中没有显式的指针类型，然而实际上对象的访问就是使用指针来实现的，即在 Java 中是使用对象的引用来替代指针的。因此在使用 Java 实现该结点结构时，一个结点本身就是一个对象。结点的数据域 data 可以使用一个 Object 类型的对象来实现，用于存储任何类型的数据元素，并通过对象的引用指向该元素；而指针域 next 可以通过节点对象的引用来实现。

由于数据域存储的也是对象引用，因此数据实际上和图中一样，是通过指向数据的物理存储地址来完成存储的，但是在后面叙述的方便，我们在图示中都将数据元素直接画到了数据域中，要注意实际的状态与之是有区别的。

上面的单链表结点结构是结点的一种最简单的形式，除此之外还有其他不同的结点结构，但是这些结点结构都有一个数据域，并均能完成数据元素的存取。为此在使用 Java 定义单链表结点结构之前先给出一个结点接口，在接口中定义了所有结点均支持的操作，即对结点中存储数据的存取。

```java
public interface Node {
    /**
     * 获取结点数据域
     */
    public Object getData();

    /**
     * 设置结点数据域
     */
    public void setData(Object obj);
}
```



**单链表结点定义**

```
package priv.starfish.linkedlist;

/**
 * @description:
 * @author: starfish
 * @data: 2020-07-27 21:43
 **/
public class SLNode implements Node {
    private Object element;
    private SLNode next;

    public SLNode() {
        this(null, null);
    }

    public SLNode(Object ele, SLNode next) {
        this.element = ele;
        this.next = next;
    }

    public SLNode getNext() {
        return next;
    }

    public void setNext(SLNode next) {
        this.next = next;
    }

    /**************** Methods of Node Interface **************/
    public Object getData() {

        return element;
    }

    public void setData(Object obj) {
        element = obj;
    }
}
```

单链表是通过上述定义的结点使用 next 域依次串联在一起而形成的。一个单链表的结构如下图所示。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gh5v8nxaecj30qy05at9i.jpg)

链表的第一个结点和最后一个结点，分别称为链表的**首结点**和**尾结点**。尾结点的特征是其 next 引用为空（null）。链表中每个结点的 next 引用都相当于一个指针，指向另一个结点，借助这些 next 引用，我们可以从链表的首结点移动到尾结点。如此定义的结点称为**单链表**（single linked list）。在单链表中通常使用 head 引用来指向链表的首结点，由 head 引用可以完成对整个链表中所有节点的访问。有时也可以根据需要使用指向尾结点的 tail 引用来方便某些操作的实现。

在单链表结构中还需要注意的一点是，由于每个结点的数据域都是一个 Object 类的对象，因此，每个数据元素并非真正如图中那样，而是在结点中的数据域通过一个 Object 类的对象引用来指向数据元素的。

与数组类似，单链表中的结点也具有一个线性次序，即如果结点 P 的 next 引用指向结点 S，则 P 就是 S 的直接前驱，S 是 P 的直接后续。单链表的一个重要特性就是只能通过前驱结点找到后续结点，而无法从后续结点找到前驱结点。在单链表中通常需要完成数据元素的查找、插入、删除等操作。下面我们逐一讨论这些操作的实现。

在单链表中进行查找操作，只能从链表的首结点开始，通过每个结点的 next 引用来一次访问链表中的每个结点以完成相应的查找操作。例如需要在单链表中查找是否包含某个数据元素 e，则方法是使用一个循环变量 p，起始时从单链表的头结点开始，每次循环判断 p所指结点的数据域是否和 e 相同，如果相同则可以返回 true，否则继续循环直到链表中所有结点均被访问，此时 p 为 null。该过程如图 3-7 所示。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gh5vcfz1cfj30ty094act.jpg)

使用 Java 语言实现整个过程的关键语句是：

```
p=head;

while (p!=null)

if (strategy.equal( e , p.getData() )) return true;

return false;
```

在单链表中查找操作的运行时间与在数组中的查找操作一样，在平均情况下需要比较大约一般的数据元素，即 T(n) ≈ n/2。

在单链表中数据元素的插入，是通过在链表中插入数据元素所属的结点来完成的。对于链表的不同位置，插入的过程会有细微的差别。图 3-8（a）、3-8（b）、3-8（c）分别说明了在单链表的表头、表尾以及链表中间插入结点的过程。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gh5vexxk6fj30qu0hc77w.jpg)

从图 3-7 中可以看出，除了单链表的首结点由于没有直接前驱结点，所以可以直接在首结点之前插入一个新的结点之外，在单链表中的其他任何位置插入一个新结点时，都只能是在已知某个特定结点引用的基础上在其后面插入一个新结点。并且在已知单链表中某个结点引用的基础上，完成结点的插入操作需要的时间是Θ(1)。由于在单链表中数据元素的插入是通过节点的插入来完成的，因此在单链表中完成数据元素的插入操作要比在数组中完成数据元素的插入操作所需Ο(n)的时间要快得多。

类似的，在单链表中数据元素的删除也是通过结点的删除来完成的。在链表的不同位置删除结点，其操作过程也会有一些差别。图 3-9（a）、3-9（b）、3-9（c）分别说明了在单链表的表头、表尾以及链表中间删除结点的过程。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gh5vfqqdjrj30pu0vsdks.jpg)



从图 3-8 中可以看出，在单链表中删除一个结点时，除首结点外都必须知道该结点的直接前驱结点的引用。并且在已知单链表中某个结点引用的基础上，完成其后续结点的删除操作需要的时间是Θ(1)。由于在单链表中数据元素的删除是通过节点的删除来完成的，因此在单链表中完成数据元素的删除操作要比在数组中完成数据元素的删除操作所需Ο(n)的时间要快得多。

通过以上分析，我们可以得出以下结论：在单链表中进行顺序查找与在数组中完成相同操作具有相同的时间复杂度，而在单链表中在已知特定结点引用的前提下完成数据元素的插入与删除操作要比在数组中完成相同操作快得多。



## 双向链表

单链表的一个优点是结构简单，但是它也有一个缺点，即在单链表中只能通过一个结点的引用访问其后续结点，而无法直接访问其前驱结点，要在单链表中找到某个结点的前驱结点，必须从链表的首结点出发依次向后寻找，但是需要Ο(n)时间。为此我们可以扩展单链表的结点结构，使得通过一个结点的引用，不但能够访问其后续结点，也可以方便的访问其前驱结点。扩展单链表结点结构的方法是，在单链表结点结构中新增加一个域，该域用于指向结点的直接前驱结点。扩展后的结点结构是构成双向链表的结点结构，如图 3-10 所示。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gh5vgpmp3zj30qg06uta5.jpg)

与单链表节点定义类似，双向链表的结点定义也可以通过实现结点接口来完成。代码

3-8 给出了双向链表结点的定义。

```java
package priv.starfish.linkedlist;

/**
 * @description:
 * @author: starfish
 * @data: 2020-07-27 21:55
 **/
public class DLNode implements Node {
    private Object element;
    private DLNode pre;
    private DLNode next;

    public DLNode() {
        this(null, null, null);
    }

    public DLNode(Object ele, DLNode pre, DLNode next) {
        this.element = ele;
        this.pre = pre;
        this.next = next;
    }

    public DLNode getNext() {
        return next;
    }

    public void setNext(DLNode next) {
        this.next = next;
    }

    public DLNode getPre() {
        return pre;
    }

    public void setPre(DLNode pre) {
        this.pre = pre;
    }

    /****************Node Interface Method**************/
    public Object getData() {
        return element;
    }

    public void setData(Object obj) {
        element = obj;
    }
}
```

双向链表是通过上述定义的结点使用 pre 以及 next 域依次串联在一起而形成的。一个双向链表的结构如图 3-11 所示。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gh5viuofdaj30pc06i405.jpg)

在双向链表中同样需要完成数据元素的查找、插入、删除等操作。在双向链表中进行查找与在单链表中类似，只不过在双向链表中查找操作可以从链表的首结点开始，也可以从尾结点开始，但是需要的时间和在单链表中一样，在平均情况下需要比较大约一般的数据元素，即 T(n) ≈ n/2。

单链表的插入操作，除了首结点之外必须在某个已知结点后面进行，而在双向链表中插入操作在一个已知的结点之前或之后都可以进行。例如在某个结点 p 之前插入一个新结点的过程如图 3-12 所示

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gh5vjend06j30r806s40h.jpg)

使用 Java 语言实现整个过程的关键语句是

s.setPre (p.getPre()); p.getPre().setNext(s);

s.setNext(p);

p.setPre(s);



在结点 p 之后插入一个新结点的操作与上述操作对称，这里不再赘述。插入操作除了上述情况，还可以在双向链表的首结点之前、双向链表的尾结点之后进行，此时插入操作与上述插入操作相比更为简单，请读者自己分析。

单链表的删除操作，除了首结点之外必须在知道待删结点的前驱结点的基础上才能进行，而在双向链表中在已知某个结点引用的前提下，可以完成该结点自身的删除。图 3-13表示了删除 p 的过程。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gh5vkep2szj30qu07ogno.jpg)

使用 Java 语言实现整个过程的关键语句是

 

p.getPre().setNext(p.getNext());

p.getNext().setPre(p.getPre());

 

如果删除的结点是首结点或尾结点时，情况会更加简单，请读者自己分析。



## **线性表的单链表实现**

在使用链表实现线性表时，既可以使用单链表，也可以使用双向链表。实现中链表的选择主要是依据需要实现的ADT的基本操作来决定，在这里我们可以选择单链表来实现线性表。在使用单链表实现线性表时，线性表中的每个数据元素对应单链表中的一个结点，而线性表元素之间的逻辑关系是通过单链表中元素所在结点之间的指向来表示的：如果表是a0, a1, …, an-1 ，那么含有元素ai-1的结点的next域应指向含有元素ai的结点(i=1,2,…,n-1)。含有an-1的那个结点的next域是null。

在使用单链表实现线性表的时候，为了使程序更加简洁，我们通常在单链表的最前面添加一个哑元结点，也称为头结点。在头结点中不存储任何实质的数据对象，其 next 域指向线性表中 0 号元素所在的结点，头结点的引入可以使线性表运算中的一些边界条件更容易处理。一个带头结点的单链表实现线性表的结构图如图 3-14 所示

 ![](https://tva1.sinaimg.cn/large/007S8ZIlly1gh5vlzh0w0j30qa06swfv.jpg)

通过图 3-12 我们发现，对于任何基于序号的插入、删除，以及任何基于数据元素所在结点的前面或后面的插入、删除，在带头结点的单链表中均可转化为在某个特定结点之后完成结点的插入、删除，而不用考虑插入、删除是在链表的首部、中间、还是尾部等不同情况。代码 3-9 给出了基于单链表实现线性表的程序。





代码 3-9 说明：在 SLinkedList 类中共有 3 个成员变量，其中 size 用于表明线性表中数据元素的个数；head 是带头结点的单链表的首结点引用；而 strategy 是用来完成线性表中数据元素的比较操作的策略。

算法 getSize()、isEmpty()的时间复杂度均为Θ(1)。通过成员变量 size 可以直接判断出线性表中数据元素的个数以及线性表是否为空。

在类中提供了两个私有方法 getPreNode(Object e)、getPreNode(int i)，其功能是找到数据元素 e 或线性表中 i 号数据元素所在结点的前驱结点。在带头结点的单链表中的插入、删除操作均是在某个结点之后完成的，因此线性表中一些基于数据元素或序号的插入、删除操作的实现依赖于对应元素在单链表中的前驱结点引用。这两个方法的平均运行时间 T(n)≈n/2。

算法 replace(int i, Object e)、get(int i)的平均时间复杂度均为Θ(n)。由于链表中每个结点在内存中的地址并不是连续的，所以链表不具有随机存取的特性，这样要对线性表中 i 号元素进行获取或替换的操作，不可能与使用数组实现线性表那样可以在常数时间内完成，而是必须从链表的头结点开始沿着链表定位 i 号元素所在的结点，然后才能进行相应的操作，因此算法的平均运行时间 T(n)≈n/2，比使用数组实现相应操作要慢得多。

算法 contains(Object e)、indexOf(Object e)主要是在线性表中查找某个数据元素。算法平均运行时间与使用数组的实现一样，都需要从线性表中 0 号元素出发，依次向后查找，因此算法运行时间 T(n) ≈ n/2。

算法 insert(int i, Object e)、remove(int i)在实现的过程中首先需要在链表中定位 i 号元素所在结点的前驱结点，然后才能完成插入、删除操作，由于定位方法 getPreNode(Object e)、getPreNode(int i)的平均运行时间约为 n/2，而真正的结点的插入与删除只需要常数时间，因此算法的运行时间 T(n)≈n/2，与使用数组实现的运行时间相同。

算法 insertBefore(Object obj, Object e)、insertAfter(Object obj, Object e)、remove(Object e)在实现的过程中 insertBefore、remove 需要找到对应元素的前驱结点，insertAfter 需要找到对应元素本身，这个定位过程的平均运行时间约为 n/2，而剩下的插入与删除操作只需要常数时间，因此整个算法的平均运行时间 T(n)≈n/2 < n，要优于使用数组实现的运行时间。



**两种实现的对比**

**3.4.1** **基于时间的比较**

 

 

线性表的操作主要有查找、插入、删除三类操作。

对于查找操作有基于序号的查找，即存取线性表中 i 号数据元素。由于数组有随机存取的特性，在线性表的顺序存储实现中可以在Θ(1)的时间内完成；而在链式存储中由于需要从头结点开始顺着链表才能取得，无法在常数时间内完成，因此顺序存储优于链式存储。查找操作还有基于元素的查找，即线性表是否包含某个元素、元素的序号是多少，这类操作线性表的顺序存储与链式存储都需要从线性表中序号为 0 的元素开始依次查找，因此两种实现的性能相同。综上所述，如果在线性表的使用中主要操作是查找，那么应当选用顺序存储实现的线性表。

对于基于数据元素的插入、删除操作而言，当使用数组实现相应操作时，首先需要采用顺序查找定位相应数据元素，然后才能插入、删除，并且在插入、删除过程又要移动大量元素；相对而言链表的实现只需要在定位数据元素的基础上，简单的修改几个指针即可完成，因此链式存储优于顺序存储。对于基于序号的插入、删除操作，因为在顺序存储中平均需要移动一半元素；而在链式存储中不能直接定位，平均需要比较一半元素才能定位。因此顺序存储与链式存储性能相当。综上所述，如果在线性表的使用中主要操作是插入、删除操作，那么选用链式存储的线性表为佳。

 

**3.4.2**  **基于空间的比较**

 

 

线性表的顺序存储，其存储空间是预先静态分配的，虽然在实现的过程中可以动态扩展数组空间，但是如果线性表的长度变化范围较大，空间在使用过程中由于会存在大量空闲空间，使得存储空间的利用率不高。而线性表的链式存储，其结点空间是动态分配的，不会存在存储空间没有完全利用的情况。因此当线性表长度变化较大时，宜采用链式存储结构。

当线性表的数据元素结构简单，并且线性表的长度变化不大时。由于链式存储结构使用了额外的存储空间来表示数据元素之间的逻辑关系，因此针对数据域而言，指针域所占比重较大；而在线性表的顺序存储结构中，没有使用额外的存储空间来表示数据元素之间的逻辑关系，尽管有一定的空闲空间没有利用，但总体而言由于线性表长度变化不大，因此没有利用的空间所占比例较小。所以当线性表数据元素结构简单，长度变化不大时可以考虑采用顺序存储结构。



**3.5** **链接表**

 

 

**3.5.1** **基于结点的操作**

 

 

在 3.1.2 小节给出的线性表抽象数据类型中，其提供的操作主要是指对线性表中的数据元素及其序号的。例如插入操作就是基于序号和元素进行的，insert(i, e)是在序号为 i 的地方插入元素，insertBefore 、与 insertAfter 是在某个数据元素之前或之后插入新的元素。这种基于序号的操作实际上并不适合采用（单向或双向）链表来实现，因为为了在链表中定位数据元素或序号，我们不得不沿着结点间的 next（或 pre）引用，从链表前端（双向链表也可以从后端）开始逐一扫描。

我们考察一种经常需要完成的操作：顺序的将线性表中每个数据元素都访问一遍。如果使用链式存储实现的线性表ListSLinked所提供的get(i)操作来实现，则需要Ο(n2)时间。因为在使用链表实现取i号数据元素的操作时，需要将结点的引用从链表前端向后移动i次，而取i+1 号数据元素时不能在上一次操作——取i号数据元素——的过程中受益，而必须重新从链表前端开始定位，则访问线性表中每个元素一次所需要的总时间为 0+1+2+…+n-1=Ο(n2)。这一时间复杂度是难以接受的。

实际上，除了通过序号来访问线性结构中的元素，还可通过其他途径来得到线性结构中的元素。例如我们能够直接通过结点来访问数据元素，通过 3.3.1 中定义的结点接口，我们看到结点实际上可以看成是可以存取数据元素的容器，数据元素与存放它的容器是一一对应的。如果能够取得结点的引用，则可以取得相应结点存储的数据元素，并且在实际应用中的许多情况下更希望以结点作为参数来完成某些操作。

如果能够以结点作为参数，那么就可以在Ο(1)时间内定位结点的地址，进而可以在更短的时间内完成相应的操作。例如如果能够直接定位在链表中进行插入和删除结点的前驱，那么相应的插入和删除操作都可以在Ο(1)完成。

 

**3.5.2** **链接表接口**

 

 

链接表可以看成是一组结点序列以及基于结点进行操作的线性结构的抽象，或者说是对

链表的抽象。

在链接表中提供基于结点的操作时，有一个问题需要考虑：需要将多少链接表的实现细节暴露给使用它的程序员？如果将单链表或双向链表的细节，例如结点结构、首结点引用或尾结点引用都提供给程序员。这样做可以使得程序员可以直接访问数据并修改内部链表结构（例如通过 next 和 pre 引用），但是基于安全性和面向对象的封装原则，我们并不这样做。那么如何在向用户提供相关链表结点引用的基础上，却可以保证用户不会通过该引用对链表的内部结构直接进行访问或修改呢？这实际上可以通过 3.1.1 定义的 Node 接口来实现，因为任何链表结点（单链表结点、双向链表结点都实现了 Node 接口）都可被 Node 类型的变量引用，而 Node 接口中只有存取数据元素的方法，因此程序员即可以存取数据，又不能对内部链表结构进行修改。

代码 3-10 给出链接表支持的操作接口定义。



结点 p 在以下情况下可以认为是不合法的：

p==null；

p 在链接表中不存在；

在调用方法 getPre(p)时，p 已经是第一个存有数据的结点；

在调用方法 getNext(p)时，p 已经是最后一个存有数据的结点。





**3.5.3** **基于双向链表实现的链接表**

 

 

在 3.3.2 小节中，为了实现双向链表结构，曾经在代码 3-8 中定义了双向链表结点结构DLNode。由于 DLNode 实现了 Node 接口，所以 DLNode 本身就是一个结点，对内部的链表而言就是组成链表的一部份，而对于外部而言就是可以存取数据元素的容器。

在使用双向链表实现链接表时，为使编程更加简洁，我们使用带两个哑元结点的双向链表来实现链接表。其中一个是头结点，另一个是尾结点，它们都不存放数据元素，头结点的pre 为空，而尾结点的 Next 为空。如此构成的双向链表结构如图 3-15 所示。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gh5vqov60mj30su06wmz4.jpg)

在具有头尾结点的双向链表中插入和删除结点，无论插入和删除的结点位置在何处，因为首尾结点的存在，插入、删除操作都可以被归结为 3.3.2 小节中介绍的在双向链表某个中间结点的插入和删除；并且因为首尾结点的存在，整个链表永远不会为空，因此在插入和删除结点之后，也不用考虑链表由空变为非空或由非空变为空的情况下 head 和 tail 的指向问题；从而简化了程序。

**基于双向链表实现的链接表**





## **迭代器**

迭代器（Iterator）是程序设计的一种模式，它属于设计模式中的行为模式，它的功能是提供一种方法顺序访问一个聚集对象中各个元素，而又不需暴露该对象的内部表示。

多个对象聚在一起形成的总体称之为聚集（Aggregate），聚集对象是能够包容一组对象的容器对象。聚集依赖于聚集结构的抽象化，具有复杂性和多样性。例如数组就是一种最基本的聚集。

聚集对象需要提供一种方法，允许用户按照一定的顺序访问其中的所有元素。而迭代器提供了一个访问聚集对象中各个元素的统一接口，简单的说迭代器就是对遍历操作的抽象。在一个迭代器中一般需要提供以下操作：

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gh5vrxmhw8j30xi0ggdna.jpg)

```
public interface Iterator { //移动到第一个元素public void first(); //移动到下一个元素public void next();
//检查迭代器中是否还有剩余的元素public boolean isDone();
//返回当前元素
public Object currentItem();
}

```

迭代器的实现可以根据不同的聚集对象给出不同的实现，下面我们结合聚集对象

LinkedList 对象，来实现针对 LinkedList 的迭代器。代码 3-14 给出了完整的实现代码。





代码 3-14 说明：由于本迭代器是基于链接表聚集对象的，因此在类中有一个成员变量为链接表对象引用；除此之外还有一个用于返回当前元素的结点对象引用。LinkedListIterator代码中各方法的正确性不难理解，且各个方法均在Ο(1)时间内完成。

在有了基于链接表聚集对象的迭代器实现以后，就可以对链接表中的数据使用迭代器接口提供的方法进行完整的遍历了。例如在代码 3-12 基于双向链表实现的链接表代码中可以对外提供一个访问所有数据元素的迭代器，即代码 3-12 中最后一个 elements()方法实现的功能。