{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{704:function(v,_,a){\"use strict\";a.r(_);var t=a(4),e=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":v.$parent.slotKey}},[a(\"h3\",{attrs:{id:\"数组\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#数组\"}},[v._v(\"#\")]),v._v(\" 数组\")]),v._v(\" \"),a(\"p\",[v._v(\"数组可以说是最基本最常见的数据结构。数组一般用来存储相同类型的数据，可通过数组名和下标进行数据的访问和更新。数组中元素的存储是按照先后顺序进行的，同时在内存中也是按照这个顺序进行连续存放。数组相邻元素之间的内存地址的间隔一般就是数组数据类型的大小。\")]),v._v(\" \"),a(\"p\",[v._v(\"因为 \"),a(\"code\",[v._v(\"字符串\")]),v._v(\" 是由字符数组形成的，所以二者是相似的。大多数面试问题都属于这个范畴。\")]),v._v(\" \"),a(\"h2\",{attrs:{id:\"前言\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#前言\"}},[v._v(\"#\")]),v._v(\" 前言\")]),v._v(\" \"),a(\"p\",[v._v(\"具体介绍数组之前，我们先来了解一下集合、列表和数组的概念之间的差别。\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"集合\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#集合\"}},[v._v(\"#\")]),v._v(\" 集合\")]),v._v(\" \"),a(\"p\",[v._v(\"集合一般被定义为：由一个或多个确定的元素所构成的整体。\")]),v._v(\" \"),a(\"p\",[v._v(\"通俗来讲，集合就是将一组事物组合在一起。你可以将力扣的题库看作一个集合：\")]),v._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://pic.leetcode-cn.com/3561000569d63aeed8957e9e45a63c67991900ca463234a3aa8a9299794bde27-1.png\",alt:\"1.png\"}})]),v._v(\" \"),a(\"p\",[v._v(\"也可以将力扣商店里的礼品看作一个集合：\")]),v._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://pic.leetcode-cn.com/c26f86483c1cdd909fa3788f32292113fc0876cdd60cbd0bb4692da722ec80e5-2.png\",alt:\"2.png\"}})]),v._v(\" \"),a(\"p\",[v._v(\"甚至可以将桌面上的物品当作一个集合。\")]),v._v(\" \"),a(\"p\",[v._v(\"集合有什么特性呢？\")]),v._v(\" \"),a(\"p\",[v._v(\"首先，\"),a(\"strong\",[v._v(\"集合里的元素类型不一定相同。\")]),v._v(\" 你可以将商品看作一个集合，也可以将整个商店看作一个集合，这个商店中有人或者其他物品也没有关系。\")]),v._v(\" \"),a(\"p\",[v._v(\"其次，\"),a(\"strong\",[v._v(\"集合里的元素没有顺序。\")]),v._v(\" 我们不会这样讲：我想要集合中的第三个元素，因为集合是没有顺序的。\")]),v._v(\" \"),a(\"p\",[v._v(\"事实上，这样的集合并不直接存在于编程语言中。然而，实际编程语言中的很多数据结构，就是在集合的基础上添加了一些规则形成的。\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"列表\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#列表\"}},[v._v(\"#\")]),v._v(\" 列表\")]),v._v(\" \"),a(\"p\",[v._v(\"列表（又称线性列表）的定义为：是一种数据项构成的有限序列，即按照一定的线性顺序，排列而成的数据项的集合。\")]),v._v(\" \"),a(\"p\",[v._v(\"列表的概念是在集合的特征上形成的，它具有顺序，且长度是可变的。你可以把它看作一张购物清单：\")]),v._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://pic.leetcode-cn.com/6453f8d5b22edca6906f8a26df2c06758102f78939cc497407ac63c5c2e4c1d9-3.png\",alt:\"3.png\"}})]),v._v(\" \"),a(\"p\",[v._v(\"在这张清单中：\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"购物清单中的条目代表的类型可能不同，但是按照一定顺序进行了排列；\")]),v._v(\" \"),a(\"li\",[v._v(\"购物清单的长度是可变的，你可以向购物清单中增加、删除条目。\")])]),v._v(\" \"),a(\"p\",[v._v(\"在编程语言中，列表最常见的表现形式有数组和链表，而我们熟悉的栈和队列则是两种特殊类型的列表。除此之外，向列表中添加、删除元素的具体实现方式会根据编程语言的不同而有所区分。\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"数组-2\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#数组-2\"}},[v._v(\"#\")]),v._v(\" 数组\")]),v._v(\" \"),a(\"p\",[v._v(\"数组是列表的实现方式之一，也是面试中经常涉及到的数据结构。\")]),v._v(\" \"),a(\"p\",[v._v(\"正如前面提到的，数组是列表的实现方式，它具有列表的特征，同时也具有自己的一些特征。然而，在具体的编程语言中，数组这个数据结构的实现方式具有一定差别。比如 C++ 和 Java 中，数组中的元素类型必须保持一致，而 Python 中则可以不同。Python 中的数组叫做 list，具有更多的高级功能。\")]),v._v(\" \"),a(\"p\",[v._v(\"那么如何从宏观上区分列表和数组呢？这里有一个重要的概念：\"),a(\"strong\",[v._v(\"索引\")]),v._v(\"。\")]),v._v(\" \"),a(\"p\",[v._v(\"首先，数组会用一些名为 \"),a(\"code\",[v._v(\"索引\")]),v._v(\" 的数字来标识每项数据在数组中的位置，且在大多数编程语言中，索引是从 \"),a(\"code\",[v._v(\"0\")]),v._v(\" 算起的。我们可以根据数组中的索引，快速访问数组中的元素。\")]),v._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://pic.leetcode-cn.com/628b6f699aa49ffcc9d3c75806457c4a1a66ffe025bb651d9f8e78b4242249b9-4.png\",alt:\"4.png\"}})]),v._v(\" \"),a(\"p\",[a(\"strong\",[v._v(\"而列表中没有索引，这是数组与列表最大的不同点\")]),v._v(\"。\")]),v._v(\" \"),a(\"p\",[v._v(\"其次，数组中的元素在内存中是连续存储的，且每个元素占用相同大小的内存。\")]),v._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://pic.leetcode-cn.com/7b17543e4e39ae894bba0b2b6f8431b40d3df04556df06a3b974146d9e5c7d0d-5.png\",alt:\"5.png\"}})]),v._v(\" \"),a(\"p\",[v._v(\"相反，列表中的元素在内存中可能彼此相邻，也可能不相邻。比如列表的另一种实现方式——链表，它的元素在内存中则不一定是连续的。\")]),v._v(\" \"),a(\"h2\",{attrs:{id:\"数组的操作\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#数组的操作\"}},[v._v(\"#\")]),v._v(\" 数组的操作\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"读取元素\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#读取元素\"}},[v._v(\"#\")]),v._v(\" 读取元素\")]),v._v(\" \"),a(\"p\",[v._v(\"读取数组中的元素，即通过数组的索引访问数组中的元素。\")]),v._v(\" \"),a(\"p\",[v._v(\"这里的索引其实就是内存地址，值得一提的是，计算机可以跳跃到任意的内存地址上，这就意味着只要计算出数组中元素的内存地址，则可以一步访问到数组中的元素。\")]),v._v(\" \"),a(\"p\",[v._v(\"可以形象地将计算机中的内存看作一系列排列好的格子，这些格子中，每一个格子对应一个内存地址，数据会存储在不同的格子中。\")]),v._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://pic.leetcode-cn.com/401fd00075501cac82e3605f91fa64ead061cfcabf839b2ba5a2eb87cd784b73-1.png\",alt:\"1.png\"}})]),v._v(\" \"),a(\"p\",[v._v(\"而对于数组，计算机会在内存中申请一段 \"),a(\"strong\",[v._v(\"连续\")]),v._v(\" 的空间，并且会记下索引为 \"),a(\"code\",[v._v(\"0\")]),v._v(\" 处的内存地址。例如对于一个数组 \"),a(\"code\",[v._v(\"['oranges', 'apples', 'bananas', 'pears', 'tomatoes']\")]),v._v(\"，为了方便起见，我们假设每个元素只占用一个字节，它的索引与内存地址的关系如下图所示。\")]),v._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://pic.leetcode-cn.com/65312e6dff56fc0c2ffad8752d6ca08da9bb7ec03211619754abd407e05147e8-2.png\",alt:\"2.png\"}})]),v._v(\" \"),a(\"p\",[v._v(\"当我们访问数组中索引为 \"),a(\"code\",[v._v(\"3\")]),v._v(\" 处的元素时，计算机会进行如下计算：\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"找到该数组的索引 \"),a(\"code\",[v._v(\"0\")]),v._v(\" 的内存地址： \"),a(\"code\",[v._v(\"2008\")]),v._v(\"；\")]),v._v(\" \"),a(\"li\",[a(\"code\",[v._v(\"pears\")]),v._v(\" 的索引为 \"),a(\"code\",[v._v(\"3\")]),v._v(\"，计算该元素的内存地址为 \"),a(\"code\",[v._v(\"2008 + 3 = 2011\")]),v._v(\"；\")])]),v._v(\" \"),a(\"p\",[v._v(\"接下来，计算机就可以在直接通过该地址访问到数组中索引为 \"),a(\"code\",[v._v(\"3\")]),v._v(\" 的元素了，计算过程很快，因此可以将整个访问过程只看作一个动作，因此时间复杂度为 $O(1)$。\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"查找元素\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#查找元素\"}},[v._v(\"#\")]),v._v(\" 查找元素\")]),v._v(\" \"),a(\"p\",[v._v(\"前面我们谈到计算机只会保存数组中索引为 \"),a(\"code\",[v._v(\"0\")]),v._v(\" 处元素的内存地址，因此当计算机想要知道数组中是否包含某个元素时，只能从索引 \"),a(\"code\",[v._v(\"0\")]),v._v(\" 处开始，逐步向后查询。\")]),v._v(\" \"),a(\"p\",[v._v(\"还是上面的例子，如果我们要查找数组中是否包含元素 \"),a(\"code\",[v._v(\"pears\")]),v._v(\"，计算机会从索引 \"),a(\"code\",[v._v(\"0\")]),v._v(\" 开始，逐个比较对应的元素，直到找到该元素后停止搜索，或到达数组的末尾后停止。\")]),v._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://pic.leetcode-cn.com/e592cf43d44a9e8f7a15b85c9fd6679668fc36134b10161bfc430b85491c8b9e-3.gif\",alt:\"3.gif\"}})]),v._v(\" \"),a(\"p\",[v._v(\"我们发现，该数组的长度为 \"),a(\"code\",[v._v(\"5\")]),v._v(\"，最坏情况下（比如我们查找元素 \"),a(\"code\",[v._v(\"tomatoes\")]),v._v(\" 或查找数组中不包含的元素），我们需要查询数组中的每个元素，因此时间复杂度为$ O(N)$，\"),a(\"em\",[v._v(\"N\")]),v._v(\" 为数组的长度。\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"插入元素\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#插入元素\"}},[v._v(\"#\")]),v._v(\" 插入元素\")]),v._v(\" \"),a(\"p\",[v._v(\"假如我们想在原有的数组中再插入一个元素 \"),a(\"code\",[v._v(\"flowers\")]),v._v(\" 呢？\")]),v._v(\" \"),a(\"p\",[v._v(\"如果要将该元素插入到数组的末尾，只需要一步。即计算机通过数组的长度和位置计算出即将插入元素的内存地址，然后将该元素插入到指定位置即可。\")]),v._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://pic.leetcode-cn.com/c3074c34fd36fd6f8b042421660705e2b376046fe50bc4af9fddc176e19f3eab-4.gif\",alt:\"4.gif\"}})]),v._v(\" \"),a(\"p\",[v._v(\"然而，如果要将该元素插入到数组中的其他位置，则会有所区别，这时我们首先需要为该元素所要插入的位置\"),a(\"code\",[v._v(\"腾出\")]),v._v(\" 空间，然后进行插入操作。比如，我们想要在索引 \"),a(\"code\",[v._v(\"2\")]),v._v(\" 处插入 \"),a(\"code\",[v._v(\"flowers\")]),v._v(\"。\")]),v._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://pic.leetcode-cn.com/27ee29524a3538e4c1de14953698a66b3e860e6b4984c1f454eb91fa9fbbc2f3-5.gif\",alt:\"5.gif\"}})]),v._v(\" \"),a(\"p\",[v._v(\"我们发现，如果需要频繁地对数组元素进行插入操作，会造成时间的浪费。事实上，另一种数据结构，即链表可以有效解决这个问题。\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"删除元素\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#删除元素\"}},[v._v(\"#\")]),v._v(\" 删除元素\")]),v._v(\" \"),a(\"p\",[v._v(\"删除元素与插入元素的操作类似，当我们删除掉数组中的某个元素后，数组中会留下 \"),a(\"code\",[v._v(\"空缺\")]),v._v(\" 的位置，而数组中的元素在内存中是连续的，这就使得后面的元素需对该位置进行 \"),a(\"code\",[v._v(\"填补\")]),v._v(\" 操作。\")]),v._v(\" \"),a(\"p\",[v._v(\"以删除索引 \"),a(\"code\",[v._v(\"1\")]),v._v(\" 中的元素 \"),a(\"code\",[v._v(\"apples\")]),v._v(\" 为例，具体过程如图所示。\")]),v._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://pic.leetcode-cn.com/20e80a7fd6d2d34ec8d59dffe1da115c76dd1c06a9a2959a03d3261a1eab67a4-6.gif\",alt:\"6.gif\"}})]),v._v(\" \"),a(\"p\",[v._v(\"同样地，数组的长度为 \"),a(\"code\",[v._v(\"5\")]),v._v(\"，最坏情况下，我们删除第一个元素，后面的 \"),a(\"code\",[v._v(\"4\")]),v._v(\" 个元素需要向前移动，加上删除操作，共需执行 \"),a(\"code\",[v._v(\"5\")]),v._v(\" 步，因此时间复杂度为 $O(N)$，\"),a(\"em\",[v._v(\"N\")]),v._v(\" 为数组的长度。\")]),v._v(\" \"),a(\"h2\",{attrs:{id:\"二维数组\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#二维数组\"}},[v._v(\"#\")]),v._v(\" 二维数组\")]),v._v(\" \"),a(\"p\",[v._v(\"二维数组是一种结构较为特殊的数组，只是将数组中的每个元素变成了一维数组。\")]),v._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://pic.leetcode-cn.com/e64116dc9c9c8f9f8ad2a5c251c0e76a677ba874a3bab0e22ce164384237a55c-1.png\",alt:\"1.png\"}})]),v._v(\" \"),a(\"p\",[v._v(\"所以二维数组的本质上仍然是一个一维数组，内部的一维数组仍然从索引 \"),a(\"code\",[v._v(\"0\")]),v._v(\" 开始，我们可以将它看作一个矩阵，并处理矩阵的相关问题。\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"示例\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#示例\"}},[v._v(\"#\")]),v._v(\" 示例\")]),v._v(\" \"),a(\"p\",[v._v(\"类似一维数组，对于一个二维数组 \"),a(\"code\",[v._v(\"A = [[1, 2, 3, 4],[2, 4, 5, 6],[1, 4, 6, 8]]\")]),v._v(\"，计算机同样会在内存中申请一段 \"),a(\"strong\",[v._v(\"连续\")]),v._v(\" 的空间，并记录第一行数组的索引位置，即 \"),a(\"code\",[v._v(\"A[0][0]\")]),v._v(\" 的内存地址，它的索引与内存地址的关系如下图所示。\")]),v._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://pic.leetcode-cn.com/bf1bd2a80e026f8ce335724e54a457301f5909cfd8ae5a25f8d2692c7cdae720-2.png\",alt:\"2.png\"}})]),v._v(\" \"),a(\"p\",[v._v(\"注意，实际数组中的元素由于类型的不同会占用不同的字节数，因此每个方格地址之间的差值可能不为 \"),a(\"code\",[v._v(\"1\")]),v._v(\"。\")]),v._v(\" \"),a(\"p\",[v._v(\"实际题目中，往往使用二维数据处理矩阵类相关问题，包括矩阵旋转、对角线遍历，以及对子矩阵的操作等。\")]),v._v(\" \"),a(\"h2\",{attrs:{id:\"刷题\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#刷题\"}},[v._v(\"#\")]),v._v(\" 刷题\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"两数之和-1\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#两数之和-1\"}},[v._v(\"#\")]),v._v(\" 两数之和(1)\")]),v._v(\" \"),a(\"blockquote\",[a(\"p\",[v._v(\"给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\")]),v._v(\" \"),a(\"p\",[v._v(\"你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\")]),v._v(\" \"),a(\"p\",[v._v(\"示例:\")]),v._v(\" \"),a(\"p\",[v._v(\"给定 nums = [2, 7, 11, 15], target = 9\")]),v._v(\" \"),a(\"p\",[v._v(\"因为 nums[0] + nums[1] = 2 + 7 = 9\\n所以返回 [0, 1]\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"买卖股票的最佳时机-121\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#买卖股票的最佳时机-121\"}},[v._v(\"#\")]),v._v(\" 买卖股票的最佳时机(121)\")]),v._v(\" \"),a(\"blockquote\",[a(\"p\",[v._v(\"给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\")]),v._v(\" \"),a(\"p\",[v._v(\"如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。\")]),v._v(\" \"),a(\"p\",[v._v(\"注意：你不能在买入股票前卖出股票。\")]),v._v(\" \"),a(\"p\",[v._v(\"示例 1:\")]),v._v(\" \"),a(\"p\",[v._v(\"输入: [7,1,5,3,6,4]\\n输出: 5\\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\\n注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\\n示例 2:\")]),v._v(\" \"),a(\"p\",[v._v(\"输入: [7,6,4,3,1]\\n输出: 0\\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"寻找两个正序数组的中位数-4\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#寻找两个正序数组的中位数-4\"}},[v._v(\"#\")]),v._v(\" 寻找两个正序数组的中位数(4)\")]),v._v(\" \"),a(\"blockquote\",[a(\"p\",[v._v(\"给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。\")]),v._v(\" \"),a(\"p\",[v._v(\"请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。\")]),v._v(\" \"),a(\"p\",[v._v(\"你可以假设 nums1 和 nums2 不会同时为空。\")]),v._v(\" \"),a(\"p\",[v._v(\"示例 1:\")]),v._v(\" \"),a(\"p\",[v._v(\"nums1 = [1, 3]\\nnums2 = [2]\")]),v._v(\" \"),a(\"p\",[v._v(\"则中位数是 2.0\\n示例 2:\")]),v._v(\" \"),a(\"p\",[v._v(\"nums1 = [1, 2]\\nnums2 = [3, 4]\")]),v._v(\" \"),a(\"p\",[v._v(\"则中位数是 (2 + 3)/2 = 2.5\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"移动零-283\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#移动零-283\"}},[v._v(\"#\")]),v._v(\" 移动零(283)\")]),v._v(\" \"),a(\"blockquote\",[a(\"p\",[v._v(\"给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\")]),v._v(\" \"),a(\"p\",[v._v(\"示例:\")]),v._v(\" \"),a(\"p\",[v._v(\"输入: [0,1,0,3,12]\\n输出: [1,3,12,0,0]\\n说明:\")]),v._v(\" \"),a(\"p\",[v._v(\"必须在原数组上操作，不能拷贝额外的数组。\\n尽量减少操作次数。\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"排序算法\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#排序算法\"}},[v._v(\"#\")]),v._v(\" 排序算法()\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"三数之和-15\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#三数之和-15\"}},[v._v(\"#\")]),v._v(\" 三数之和(15)\")]),v._v(\" \"),a(\"blockquote\",[a(\"p\",[v._v(\"给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。\")]),v._v(\" \"),a(\"p\",[v._v(\"注意：答案中不可以包含重复的三元组。\")]),v._v(\" \"),a(\"p\",[v._v(\"示例：\")]),v._v(\" \"),a(\"p\",[v._v(\"给定数组 nums = [-1, 0, 1, 2, -1, -4]，\")]),v._v(\" \"),a(\"p\",[v._v(\"满足要求的三元组集合为：\\n[\\n[-1, 0, 1],\\n[-1, -1, 2]\\n]\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"最小路径和-64\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#最小路径和-64\"}},[v._v(\"#\")]),v._v(\" 最小路径和(64)\")]),v._v(\" \"),a(\"blockquote\",[a(\"p\",[v._v(\"给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\")]),v._v(\" \"),a(\"p\",[v._v(\"说明：每次只能向下或者向右移动一步。\")]),v._v(\" \"),a(\"p\",[v._v(\"示例:\")]),v._v(\" \"),a(\"p\",[v._v(\"输入:\\n[\\n[1,3,1],\\n[1,5,1],\\n[4,2,1]\\n]\\n输出: 7\\n解释: 因为路径 1→3→1→1→1 的总和最小。\")])]),v._v(\" \"),a(\"h3\",{attrs:{id:\"双索引技巧-对撞指针\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#双索引技巧-对撞指针\"}},[v._v(\"#\")]),v._v(\" 双索引技巧-对撞指针\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"双索引技巧-滑动窗口\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#双索引技巧-滑动窗口\"}},[v._v(\"#\")]),v._v(\" 双索引技巧-滑动窗口\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"稀疏数组\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#稀疏数组\"}},[v._v(\"#\")]),v._v(\" 稀疏数组\")])])}),[],!1,null,null,null);_.default=e.exports}}]);","extractedComments":[]}