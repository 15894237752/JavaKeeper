各种锁总结



- 公平锁、非公平锁
- 可重入锁（又名递归锁）
- 自旋锁
- 悲观锁
- 乐观锁
- 共享锁
- 独占锁
- 排它锁



## 公平锁/非公平锁

公平锁：是指多个线程按照申请锁的顺序来获取锁，类似排队打饭，先来后到

非公平锁：是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。在高并发的情况下，有可能会造成优先级反转或饥饿现象。

并发包中 ReentrantLock 的创建可以指定构造函数的 boolean 类型来得到公平锁或非公平锁，默认为非公平锁。



### 区别

公平锁，就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照 FIFO 的规则从队列中取到自己。

非公平锁，比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁的方式。

Java ReentrantLock 而言，通过构造函数指定该锁是否公平，默认是非公平锁。非公平锁的有点在于吞吐量比公平锁大。 对于 Synchronized 而言，也是一种非公平锁。





## 可重入锁/递归锁

可重入锁，也叫递归锁。

指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码，在同一线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。

也就是说，线程可以进入任何一个它已经拥有的锁锁同步着的代码块。



ReentrackLock、Synchronized 就是一个典型的可重入锁。



可重入锁的最大作用是避免死锁。

```java
public class ReentrantLockDemo {

    public static void main(String[] args) {
        Phone phone = new Phone();

        new Thread(()->{
            phone.sendMSM();

        },"t1").start();


        new Thread(()->{
            phone.sendMSM();

        },"t2").start();

        Thread t3 = new Thread(phone);
        Thread t4 = new Thread(phone);
        t3.start();
        t4.start();
    }


}

class Phone implements Runnable{

    public synchronized void sendMSM(){
        System.out.println(Thread.currentThread().getName()+"\t send msm");
        sendEmail();
    }

    public synchronized void sendEmail(){
        System.out.println(Thread.currentThread().getName()+"\t send email");
    }

    //------

    Lock lock = new ReentrantLock();

    @Override
    public void run(){
        get();
    }

    private void get() {
        lock.lock();
        try {
            System.out.println(Thread.currentThread().getName()+"\t invoke get");
            set();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }

    private void set() {
        lock.lock();
        try {
            System.out.println(Thread.currentThread().getName()+"\t invoke set");
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
}
```





## 自旋锁

spinlock

是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗 CPU

```java
/**
 * 自旋锁
 *
 * 手写一个自旋锁
 *
 * 通过 CAS 操作完成自旋锁，A 线程先进来调用myLock 方法自己持有锁 5 秒
 * B 线程随后进来发现当前有线程持有锁，不是 null,所以只能通过自旋等待，
 * 知道A 释放锁后B 随后抢到
 **/
public class SpinLockDemo {

    AtomicReference<Thread> lock = new AtomicReference<>();

    public void myLock(){
        Thread thread = Thread.currentThread();

        System.out.println(Thread.currentThread().getName() + "\t get  lock");
        //如果不为空，自旋
        while (! lock.compareAndSet(null,thread)){

        }
    }

    public void myUnlock(){
        Thread thread = Thread.currentThread();
        System.out.println(Thread.currentThread().getName()+"\t unlock");
        //解锁后，将锁置为 null
        lock.compareAndSet(thread,null);
    }

    public static void main(String[] args) {

        SpinLockDemo spinLockDemo = new SpinLockDemo();
        new Thread(()->{

            spinLockDemo.myLock();
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            spinLockDemo.myUnlock();

        },"t1").start();

        new Thread(()->{
            spinLockDemo.myLock();
            spinLockDemo.myUnlock();

        },"t2").start();
    }
}
```





## 独占锁（写锁）、共享锁（读锁）、互斥锁

独占锁：指该锁一次只能被一个线程所持有，对 ReentrantLock和 Synchronized 而言都是独占锁

共享锁：指该锁可被多个线程所持有

对 ReentrantReadWriteLock 其读锁是共享锁，其写锁是独占锁。

读锁的共享锁可保证并发读是非常高效的，读写、写读、写写的过程是互斥的。

```java
/**
 * 多个线程同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行
 * <p>
 * 但是如果一个线程想去写共享资源，就不应该再有其他线程对该资源进行读和写
 **/
public class ReadWriteLockDemo {
    public static void main(String[] args) {
        MyCache cache = new MyCache();
        for (int i = 0; i < 5; i++) {
            final int tempInt = i;
            new Thread(() -> {
                cache.put(tempInt + "", tempInt + "");
            }, String.valueOf(i)).start();
        }

        //5 个线程读
        for (int i = 0; i < 5; i++) {
            final int tempInt = i;
            new Thread(() -> {
                cache.get(tempInt + "");
            }, String.valueOf(i)).start();
        }
    }


}


//以一个缓存做例子，写缓存和读缓存
class MyCache {
    volatile Map<String, Object> map = new HashMap<>();

    private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();

    public void put(String key, Object value) {

        lock.writeLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + "\t 正在写入" + key);
            //模拟网络拥堵
            TimeUnit.MICROSECONDS.sleep(300);
            map.put(key, value);
            System.out.println(Thread.currentThread().getName() + "\t 写入完成");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.writeLock().unlock();
        }
    }

    public void get(String key) {

        lock.writeLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + "\t 正在读取");
            //模拟网络拥堵
            TimeUnit.MICROSECONDS.sleep(300);
            System.out.println(Thread.currentThread().getName() + "\t 读取完成" + map.get(key));
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.writeLock().unlock();
        }

    }
}
```



## 对各种锁的理解？请手写一个自旋锁