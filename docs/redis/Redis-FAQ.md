漫画， 来了。， 我们这个造飞机工程师岗位，肯定得需要redis使用经验的，我问你一些rediss问题吧

凯颇儿 是吧，



> 你能说说 Redis 是什么吗，有什么特点

### Redis是什么

Redis：**REmote DIctionary Server**(远程字典服务器)。

Redis 是一个全开源免费（BSD许可）的，内存中的数据结构存储系统，它可以用作**数据库、缓存和消息中间件**

和 Memcached 类似，它支持存储的 value 类型相对更多，包括**string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）、bitmap、hyperloglog、GeoHash、streams**。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。后来的版本还提供了HyperLogLog、GeoHash等更高级的数据类型。

- 性能优秀，数据在内存中，读写速度非常快，支持并发10W QPS
- 单进程单线程，是线程安全的，采用IO多路复用机制
- Redis 数据库完全在内存中，使用磁盘仅用于持久性
- 相比许多键值数据存储，Redis 拥有一套较为丰富的数据类型
- 操作都是**原子性**：所有 Redis 操作是原子的，这保证了如果两个客户端同时访问的Redis服务器将获得更新后的值
- Redis 可以将数据复制到任意数量的从服务器（主从复制，哨兵，高可用）



> Redis 都支持哪些数据类型

### Redis数据类型

Redis不是简单的键值存储，它实际上是一个数据结构服务器，支持不同类型的值。

- String（字符串）：二进制安全字符串
- List（列表）：根据插入顺序排序的字符串元素的集合。它们基本上是链表
- Set（集合）：唯一，未排序的字符串元素的集合
- zset(sorted set：有序集合)：相当于有序的 Set集合，每个字符串元素都与一个称为 *score* 的浮点值相关联。元素总是按它们的分数排序（eg，找出前10名或后10名）
- Hash（字典）：是一个键值对集合。KV模式不变，但V是一个键值对
- Bit arrays （位数组，简称位图）：
- HyperLogLog（）：这是一个概率数据结构，用于估计集合的基数
- Streams：

Redis 提供了五种基本数据类型，String、Hash、List、Set、zset(sorted set：有序集合)。还新增了：基数统计HyperLogLog、查询附近的人GeoHash、更好支持消息队列的Streams等

由于Redis是基于标准C写的，只有最基础的数据类型，因此Redis为了满足对外使用的5种数据类型，开发了属于自己**独有的一套基础数据结构**，使用这些数据结构来实现5种数据类型。

Redis底层的数据结构包括：**简单动态数组SDS、链表、字典、跳跃链表、整数集合、压缩列表、对象。**

Redis为了平衡空间和时间效率，针对value的具体类型在底层会采用不同的数据结构来实现，其中哈希表和压缩列表是复用比较多的数据结构，如下图展示了对外数据类型和底层数据结构之间的映射关系：

![img](https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaS8FxVXL1em0ozmuyF9fVur7tcKIz1UycrwHu4J9E70iaOjIriazWNFJpBMUsHe4MNysicSK5u73Fvg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

------

![img](https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qasdXmojIeu5L2qr9FvdYFAUPrtL5ztfz90zmKHkaA8bbZ7ZXTKNOeF56Q4bcgPEP3gfkK83ppOhw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

从图中可以看到**ziplist压缩列表**可以作为Zset、Hash、List三种数据类型的底层实现，看来很强大，压缩列表是一种为了节约内存而开发的且经过特殊编码之后的连续内存块顺序型数据结构，底层结构还是比较复杂的。

![img](https://user-gold-cdn.xitu.io/2019/11/14/16e68ee882352143?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### String（字符串）

string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。

string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。

Redis 的字符串是动态字符串，是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配，如图中所示，内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度 len。当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是字符串最大长度为 512M。

[![redis-string.jpg](https://camo.githubusercontent.com/0db654ecd84f5e3bd7c733872c899118d2287de6/687474703a2f2f7777312e73696e61696d672e636e2f6c617267652f39623966303961396c7931673979706f6f626566356a323066773034707132702e6a7067)](https://camo.githubusercontent.com/0db654ecd84f5e3bd7c733872c899118d2287de6/687474703a2f2f7777312e73696e61696d672e636e2f6c617267652f39623966303961396c7931673979706f6f626566356a323066773034707132702e6a7067)

#### Hash（字典）

Redis hash 是一个键值对集合。KV模式不变，但V是一个键值对。

Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。

Redis 的字典相当于 Java 语言里面的 HashMap，它是无序字典， 内部实现结构上同 Java 的 HashMap 也是一致的，同样的数组 + 链表二维结构。第一维 hash 的数组位置碰撞时，就会将碰撞的元素使用链表串接起来。

[![redis-hash.jpg](https://camo.githubusercontent.com/8466f854d1d11f1cc2ad7b8ae853e345a9668714/687474703a2f2f7777312e73696e61696d672e636e2f6c617267652f39623966303961396c7931673979707032727330356a323067333037706139752e6a7067)](https://camo.githubusercontent.com/8466f854d1d11f1cc2ad7b8ae853e345a9668714/687474703a2f2f7777312e73696e61696d672e636e2f6c617267652f39623966303961396c7931673979707032727330356a323067333037706139752e6a7067)

#### List（列表）

Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。

它的底层实际是个链表，

**Redis 的列表相当于 Java 语言里面的 LinkedList，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)**

Redis 的列表结构常用来做异步队列使用。将需要延后处理的任务结构体序列化成字符串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理

##### 右边进左边出：队列

```
> rpush books python java golang 
(integer) 3 
\> llen books
 (integer) 3 
\> lpop books
 "python" 
\> lpop books
 "java" 
\> lpop books 
"golang" 
\> lpop books 
(nil)
```

##### 右边进右边出：栈

```
> rpush books python java golang
 (integer) 3
 \> rpop books 
"golang" 
\> rpop books 
"java" 
\> rpop books 
"python"
 \> rpop books
 (nil)
```

#### Set（集合）

Redis的Set是string类型的无序集合。它是通过HashTable实现的， 相当于 Java 语言里面的 HashSet，它内部的键值对是无序的唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值`NULL`。

#### zset(sorted set：有序集合)

Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。

redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。

它类似于 Java 的 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的排序权重。它的内部实现用的是一种叫做「跳跃列表」的数据结构。



> 这些基本知识都会了，那你知道Redis一般用在哪些场景吗，你们项目中是怎么用Redis的

### redis使用场景

- 取最新N个数据的操作
- 排行榜应用,取TOP N 操作
- 需要精确设定过期时间的应用
- 定时器、计数器应用
- Uniq操作,获取某段时间所有数据排重值
- 实时系统,反垃圾系统
- Pub/Sub构建实时消息系统
- 构建队列系统
- 缓存

 

> 用缓存，肯定是因为他快，那为什么快呢
>
> redis这么快，它的“多线程模型”你了解吗？（露出邪魅一笑）

### Redis为何这么快

您是想问Redis这么快，为什么还是单线程的吧。Redis确实是单进程单线程的模型，因为Redis完全是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章的采用单线程的方案了（毕竟采用多线程会有很多麻烦）。

第一：Redis完全基于内存，绝大部分请求是纯粹的内存操作，非常迅速，数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度是O(1)。第二：数据结构简单，对数据操作也简单。第三：采用单线程，避免了不必要的上下文切换和竞争条件，不存在多线程导致的CPU切换，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有死锁问题导致的性能消耗。第四：使用多路复用IO模型，非阻塞IO



> 你有提到过memcached，那你为什么选择Redis的缓存方案而不用memcached呢

### Redis和Memcached的区别

1、存储方式上：memcache会把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。redis有部分数据存在硬盘上，这样能保证数据的持久性。2、数据支持类型上：memcache对数据类型的支持简单，只支持简单的key-value，，而redis支持五种数据类型。3、使用底层模型不同：它们之间底层实现方式以及与客户端之间通信的应用协议不一样。redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。4、value的大小：redis可以达到1GB，而memcache只有1MB。






> 我看你们有把 Redis 用作缓存，缓存和数据库数据一致性问题

### 缓存和数据库数据一致性问题

分布式环境下非常容易出现缓存和数据库间数据一致性问题，针对这一点，如果项目对缓存的要求是强一致性的，那么就不要使用缓存。我们只能采取合适的策略来降低缓存和数据库间数据不一致的概率，而无法保证两者间的强一致性。合适的策略包括合适的缓存更新策略，更新数据库后及时更新缓存、缓存失败时增加重试机制。





## Redis雪崩了解吗？

> 你们 怎么解决？



> 那你说说你知道的redis的淘汰策略有哪些？

### 淘汰策略

Redis有六种淘汰策略

| 策略            | 描述                                                         |
| --------------- | ------------------------------------------------------------ |
| volatile-lru    | 从已设置过期时间的KV集中优先对最近最少使用(less recently used)的数据淘汰 |
| volitile-ttl    | 从已设置过期时间的KV集中优先对剩余时间短(time to live)的数据淘汰 |
| volitile-random | 从已设置过期时间的KV集中随机选择数据淘汰                     |
| allkeys-lru     | 从所有KV集中优先对最近最少使用(less recently used)的数据淘汰 |
| allKeys-random  | 从所有KV集中随机选择数据淘汰                                 |
| noeviction      | 不淘汰策略，若超过最大内存，返回错误信息                     |



## 持久化

> 你对redis的持久化机制了解吗？能讲一下吗？

Redis 的数据全部在内存里，如果突然宕机，数据就会全部丢失，因此必须有一种机制来保证 Redis 的数据不会因为故障而丢失，这种机制就是 Redis 的持久化机制。

**Redis有两种持久化的方式：快照（`RDB`文件）和追加式文件（`AOF`文件)**

## RDB（Redis DataBase）

#### 是什么

**在指定的时间间隔内将内存中的数据集快照写入磁盘**，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。

Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能，如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 RDB 方式要比 AOF 方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。

**?** What ? Redis 不是单进程的吗?

Redis 使用操作系统的多进程 COW(Copy On Write) 机制来实现快照持久化， fork是类Unix操作系统上**创建进程**的主要方法。COW(Copy On Write)是计算机编程中使用的一种优化策略。

#### Fork

fork 的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。 子进程读取数据，然后序列化写到磁盘中

rdb 默认保存的是**dump.rdb**文件

你可以对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。

你也可以通过调用 [SAVE](http://redisdoc.com/server/save.html#save) 或者 [BGSAVE](http://redisdoc.com/server/bgsave.html#bgsave) ， 手动让 Redis 进行数据集保存操作。

比如说， 以下设置会让 Redis 在满足“ 60 秒内有至少有 1000 个键被改动”这一条件时， 自动保存一次数据集：

```
save 60 1000
```

这种持久化方式被称为快照（snapshot）。

**配置位置**： SNAPSHOTTING

[![redis-snapshotting.png](https://camo.githubusercontent.com/1bc977cc3e9a0c56ec251e71a815dde144714bb6/68747470733a2f2f692e6c6f6c692e6e65742f323031392f31322f32342f4a6a614f39526f684c70764677346b2e706e67)](https://camo.githubusercontent.com/1bc977cc3e9a0c56ec251e71a815dde144714bb6/68747470733a2f2f692e6c6f6c692e6e65742f323031392f31322f32342f4a6a614f39526f684c70764677346b2e706e67)

#### 如何触发RDB快照

- 配置文件中默认的快照配置

  冷拷贝后重新使用 可以`cp dump.rdb dump_new.rdb`

- 命令save或者是bgsave

  - **Save**：save时只管保存，其它不管，全部阻塞
  - **BGSAVE**：Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。可以通过lastsave命令获取最后一次成功执行快照的时间
  - 执行**flushall**命令，也会产生dump.rdb文件，但里面是空的，无意义

#### 快照的运作方式

当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作：

1. Redis 调用 fork() ，产生一个子进程，此时同时拥有父进程和子进程。
2. 子进程将数据集写入到一个临时 RDB 文件中。
3. 当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。

这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。

#### 如何恢复

将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可（CONFIG GET dir获取目录）

#### 优势

- 一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于**文件备份**而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。**适合大规模的数据恢复**
- 对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。
- 性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。
- 相比于AOF机制，如果数据集很大，RDB的启动效率会更高。

#### 劣势

- 如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失（丢失最后一次快照后的所有修改）。
- 由于RDB是通过fork子进程来协助完成数据持久化工作的，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。

#### 如何停止

动态停止RDB保存规则的方法：`redis-cli config set save ""`

#### 总结

[![redis-rdb.png](https://camo.githubusercontent.com/4352c45532dfe5154ff8d7053f149966a08e9150/68747470733a2f2f692e6c6f6c692e6e65742f323031392f31312f31382f37357a655561664f734e546b496c772e706e67)](https://camo.githubusercontent.com/4352c45532dfe5154ff8d7053f149966a08e9150/68747470733a2f2f692e6c6f6c692e6e65742f323031392f31312f31382f37357a655561664f734e546b496c772e706e67)

- RDB是一个非常紧凑的文件
- RDB在保存RDB文件时父进程唯一需要做的就是fork出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他IO操作，所以RDB持久化方式可以最大化redis的性能
- 与AOF相比，在恢复大的数据集的时候，RDB方式会更快一些
- 数据丢失风险大
- RDB需要经常fork子进程来保存数据集到硬盘上，当数据集比较大的时候，fork的过程是非常耗时的，可能会导致redis在一些毫秒级不能响应客户端的请求

## AOF（Append Only File）

#### 是什么

以日志的形式来记录每个写操作，将 Redis 执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件，redis 启动之初会读取该文件重新构建数据，也就是「重放」。换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。

AOF 默认保存的是 **appendonly.aof ** 文件

**配置位置**： APPEND ONLY MODE

[![redis-aof-conf.jpg](https://camo.githubusercontent.com/c9d5d35b64bdd960a99e68296f7f1482598e1416/68747470733a2f2f692e6c6f6c692e6e65742f323031392f31322f32342f703242665536657956386d6976334e2e6a7067)](https://camo.githubusercontent.com/c9d5d35b64bdd960a99e68296f7f1482598e1416/68747470733a2f2f692e6c6f6c692e6e65742f323031392f31322f32342f703242665536657956386d6976334e2e6a7067)

#### AOF启动/修复/恢复

- 正常恢复
  - 启动：设置Yes 修改默认的appendonly no，改为yes
  - 将有数据的 aof 文件复制一份保存到对应目录(config get dir)
  - 恢复：重启redis然后重新加载
- 异常恢复
  - 启动：设置Yes 修改默认的appendonly no，改为yes
  - 备份被写坏的AOF文件
  - 修复：**redis-check-aof --fix**进行修复 + AOF文件
  - 恢复：重启redis然后重新加载

#### rewrite（AOF 重写）

- 是什么：AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制,当 AOF 文件的大小超过所设定的阈值时，Redis就会启动 AOF 文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令`bgrewriteaof`
- 重写原理：AOF 文件持续增长而过大时，会 fork 出一条新进程来将文件重写(也是先写临时文件最后再rename)，遍历新进程的内存中数据，每条记录有一条的 Set 语句。重写 aof 文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的 aof 文件，这点和快照有点类似
- 触发机制：Redis 会记录上次重写时的 AOF 大小，默认配置是当 AOF 文件大小是上次 rewrite 后大小的一倍且文件大于64M 时触发

#### AOF耐久性

你可以配置 Redis 多久才将数据 fsync 到磁盘一次。

有三个选项：

- 每次有新命令追加到 AOF 文件时就执行一次 fsync ：非常慢，也非常安全。
- 每秒 fsync 一次：足够快（和使用 RDB 持久化差不多），并且在故障时只会丢失 1 秒钟的数据。
- 从不 fsync ：将数据交给操作系统来处理。更快，也更不安全的选择。

推荐（并且也是默认）的措施为每秒 fsync 一次， 这种 fsync 策略可以兼顾速度和安全性。

总是 fsync 的策略在实际使用中非常慢，频繁调用 fsync 注定了这种策略不可能快得起来。

#### 如果 AOF 文件出错了，怎么办？

服务器可能在程序正在对 AOF 文件进行写入时停机， 如果停机造成了 AOF 文件出错（corrupt）， 那么 Redis 在重启时会拒绝载入这个 AOF 文件， 从而确保数据的一致性不会被破坏。

当发生这种情况时， 可以用以下方法来修复出错的 AOF 文件：

1. 为现有的 AOF 文件创建一个备份。
2. 使用 Redis 附带的 redis-check-aof 程序，对原来的 AOF 文件进行修复。

**$ redis-check-aof --fix**

1. （可选）使用 diff -u 对比修复后的 AOF 文件和原始 AOF 文件的备份，查看两个文件之间的不同之处。
2. 重启 Redis 服务器，等待服务器载入修复后的 AOF 文件，并进行数据恢复。

#### AOF运作方式

AOF 重写和 RDB 创建快照一样，都巧妙地利用了写时复制机制。

以下是 AOF 重写的执行步骤：

1. Redis 执行 fork() ，现在同时拥有父进程和子进程。
2. 子进程开始将新 AOF 文件的内容写入到临时文件。
3. 对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾： 这样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。
4. 当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。
5. 搞定！现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。

#### 优势

- 该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3种同步策略，即**每秒同步、每修改同步和不同步**。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。
- 由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过**redis-check-aof**工具来帮助我们解决数据一致性的问题。
- 如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。
- AOF 包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 [FLUSHALL](http://redisdoc.com/server/flushall.html#flushall) 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。

#### 劣势

- 对于相同数量的数据集而言，AOF文件通常要大于RDB文件。恢复速度慢于rdb。
- 根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。

#### 总结

[![redis-aof.png](https://camo.githubusercontent.com/dfc6ddc923dce1f8af1f352b89fc1eab54bfe972/68747470733a2f2f692e6c6f6c692e6e65742f323031392f31322f32352f325941674b7873535452486c71616f2e706e67)](https://camo.githubusercontent.com/dfc6ddc923dce1f8af1f352b89fc1eab54bfe972/68747470733a2f2f692e6c6f6c692e6e65742f323031392f31322f32352f325941674b7873535452486c71616f2e706e67)

- AOF 文件是一个只进行追加的日志文件
- Redis 可以在 AOF 文件体积变得过大时，自动在后台对 AOF 进行重写
- AOF文件有序的保存了对数据库执行的所有写入操作，这些写入操作以Redis协议的格式保存，因此AOF文件的内容非常容易被人读懂，对文件进行分析也很轻松
- 对于相同的数据集来说，AOF 文件的体积通常需要大于 RDB 文件的体积
- 根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB

**怎么从 RDB 持久化切换到 AOF 持久化**

在 Redis 2.2 或以上版本，可以在不重启的情况下，从 RDB 切换到 AOF ：

1. 为最新的 dump.rdb 文件创建一个备份。
2. 将备份放到一个安全的地方。
3. 执行以下两条命令：

```
 redis-cli> CONFIG SET appendonly yes 	

 redis-cli> CONFIG SET save "" 
```

1. 确保命令执行之后，数据库的键的数量没有改变。
2. 确保写命令会被正确地追加到 AOF 文件的末尾。

步骤 3 执行的第一条命令开启了 AOF 功能： Redis 会阻塞直到初始 AOF 文件创建完成为止， 之后 Redis 会继续处理命令请求， 并开始将写入命令追加到 AOF 文件末尾。

步骤 3 执行的第二条命令用于关闭 RDB 功能。 这一步是可选的， 如果你愿意的话， 也可以同时使用 RDB 和 AOF 这两种持久化功能。

别忘了在 redis.conf 中打开 AOF 功能！ 否则的话， 服务器重启之后， 之前通过 CONFIG SET 设置的配置就会被遗忘， 程序会按原来的配置来启动服务器。

## Which one

- RDB 持久化方式能够在指定的时间间隔能对你的数据进行快照存储
- AOF 持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以 redis 协议追加保存每次写的操作到文件末尾。Redis还能对AOF文件进行后台重写（**bgrewriteaof**）,使得 AOF 文件的体积不至于过大
- 只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式。
- 同时开启两种持久化方式
  - 在这种情况下,当 redis 重启的时候会优先载入 AOF 文件来恢复原始的数据,因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整。
  - RDB 的数据不实时，同时使用两者时服务器重启也只会找 AOF 文件。那要不要只使用AOF 呢？建议不要，因为 RDB 更适合用于备份数据库(AOF 在不断变化不好备份)，快速重启，而且不会有 AOF 可能潜在的bug，留着作为一个万一的手段。

#### 性能建议

- 因为 RDB 文件只用作后备用途，建议只在 Slave上持久化 RDB 文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。
- 如果Enalbe AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的 AOF 文件就可以了。代价一是带来了持续的 IO，二是 AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少 AOF rewrite 的频率，AOF 重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。
- 如果不 Enable AOF ，仅靠 Master-Slave Replication 实现高可用性也可以。能省掉一大笔 IO ，也减少了rewrite 时带来的系统波动。代价是如果 Master/Slav e同时宕掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个。

## 



## 主从复制

> redis单节点存在单点故障问题，为了解决单点问题，一般都需要对redis配置从节点，然后使用哨兵来监听主节点的存活状态，如果主节点挂掉，从节点能继续提供缓存功能，你能说说redis主从复制的过程和原理吗？



## 哨兵



## 事务





## 分布式锁